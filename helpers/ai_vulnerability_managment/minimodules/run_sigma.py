import json
import traceback

# Assuming these are imported elsewhere in your code
import modules.Velociraptor.VelociraptorScript
from pyvelociraptor import api_pb2
from pyvelociraptor import api_pb2_grpc

def convert_sigma_rules_to_string(sigma_rules_dict, logger):
    """
    Converts a dictionary of Sigma rules to a string format that can be used in Velociraptor.
    
    Args:
        sigma_rules_dict (dict): Dictionary containing Sigma rules keyed by CVE.
        logger: Logger object for logging messages.
    
    Returns:
        str: Sigma rules in string format.
    """
    try:
        logger.info("Converting Sigma rules to string format")
        sigma_rules_text = ""
        
        # Process each CVE and its associated rules
        for cve_id, rules in sigma_rules_dict.items():
            for rule_obj in rules:
                # Extract rule title or use a default
                rule_title = rule_obj.get("title", f"Rule for {cve_id}")
                
                # Extract rule ID or use a default
                rule_id = rule_obj.get("id", f"rule-{cve_id}")
                
                # Start building the rule
                sigma_rules_text += f"title: {rule_title}\n"
                sigma_rules_text += f"id: {rule_id}\n"
                
                # Add status
                if "status" in rule_obj:
                    sigma_rules_text += f"status: {rule_obj['status']}\n"
                
                # Add description
                if "description" in rule_obj:
                    description = rule_obj["description"].replace("\\", "\\\\")  # Escape backslashes
                    sigma_rules_text += f"description: {description}\n"
                
                # Add date
                if "date" in rule_obj:
                    sigma_rules_text += f"date: {rule_obj['date']}\n"
                
                # Add author
                if "author" in rule_obj:
                    sigma_rules_text += f"author: {rule_obj['author']}\n"
                
                # Add logsource
                if "logsource" in rule_obj:
                    logsource = rule_obj["logsource"]
                    sigma_rules_text += "logsource:\n"
                    
                    for key, value in logsource.items():
                        sigma_rules_text += f"    {key}: {value}\n"
                
                # Add detection
                if "detection" in rule_obj:
                    detection = rule_obj["detection"]
                    sigma_rules_text += "detection:\n"
                    
                    for key, value in detection.items():
                        # Handle nested dictionaries (like selection criteria)
                        if isinstance(value, dict):
                            sigma_rules_text += f"    {key}:\n"
                            for subkey, subvalue in value.items():
                                # Handle list values (like contains)
                                if isinstance(subvalue, list):
                                    sigma_rules_text += f"        {subkey}:\n"
                                    for item in subvalue:
                                        # Escape backslashes in Windows paths
                                        item = item.replace("\\", "\\\\")
                                        sigma_rules_text += f"            - '{item}'\n"
                                else:
                                    # Escape backslashes in Windows paths
                                    if isinstance(subvalue, str):
                                        subvalue = subvalue.replace("\\", "\\\\")
                                    sigma_rules_text += f"        {subkey}: '{subvalue}'\n"
                        # Handle strings (like condition)
                        elif isinstance(value, str):
                            sigma_rules_text += f"    {key}: {value}\n"
                        # Handle condition when it's not a string but a nested key
                        elif key == "condition" and isinstance(value, dict):
                            sigma_rules_text += f"    {key}:\n"
                            for cond_key, cond_value in value.items():
                                sigma_rules_text += f"        {cond_key}: {cond_value}\n"
                
                # Add false positives
                if "falsepositives" in rule_obj:
                    falsepositives = rule_obj["falsepositives"]
                    sigma_rules_text += "falsepositives:\n"
                    
                    for item in falsepositives:
                        # Escape backslashes
                        item = item.replace("\\", "\\\\")
                        sigma_rules_text += f"    - '{item}'\n"
                
                # Add level
                if "level" in rule_obj:
                    sigma_rules_text += f"level: {rule_obj['level']}\n"
                
                # Add separator between rules
                sigma_rules_text += "---\n"
        
        logger.info(f"Successfully converted {len(sigma_rules_dict)} CVE rules to Sigma format")
        return sigma_rules_text.strip()
        
    except Exception as e:
        logger.error(f"Error converting Sigma rules to string: {str(e)}")
        logger.error(traceback.format_exc())
        return ""

def format_arguments(params):
    """
    Format artifact parameters for use in Velociraptor query.
    
    Args:
        params (dict): Parameters to format
        
    Returns:
        str: Formatted parameters string
    """
    formatted_arguments = ", ".join(
        f'{key}= "{value}"' for key, value in params.items()
    )
    return formatted_arguments

def run_hunt(query, channel, stub, logger):
    """
    Execute a hunt and return the hunt ID.
    
    Args:
        query (str): VQL query to execute
        channel: gRPC channel
        stub: API stub
        logger: Logger object
        
    Returns:
        tuple: (hunt_id, status, error_message)
    """
    try:
        hunt_id = None
        request = api_pb2.VQLCollectorArgs(Query=[api_pb2.VQLRequest(VQL=query)])
        
        for response in stub.Query(request):
            logger.info(f"Raw response from Velociraptor: {response.Response}")
            if response.Response and response.Response != "[]":
                try:
                    parsed_json = json.loads(response.Response)
                    if parsed_json and len(parsed_json) > 0:
                        # Try different possible field names for hunt ID
                        if "HuntId" in parsed_json[0]:
                            hunt_id = parsed_json[0]["HuntId"]
                        elif "hunt_id" in parsed_json[0]:
                            hunt_id = parsed_json[0]["hunt_id"]
                            
                        if hunt_id:
                            logger.info(f"Hunt started with ID: {hunt_id}")
                            return hunt_id, "Running", ""
                except Exception as e:
                    error_msg = f"Error parsing response: {str(e)}"
                    logger.error(error_msg)
                    return "", "Failed", error_msg
        
        return "", "Failed", "No hunt ID returned"
        
    except Exception as e:
        error_msg = f"Error executing hunt: {str(e)}"
        logger.error(error_msg)
        logger.error(traceback.format_exc())
        return "", "Failed", error_msg

def run_sigma_scan(general_settings, sigma_rules_dict, logger):
    """
    Launches Windows.Sigma.EventLogs artifact without waiting for results.
    
    Args:
        general_settings: Dictionary containing configuration settings
        sigma_rules_dict: Dictionary containing Sigma rules
        logger: Logger object for logging messages
    
    Returns:
        str: Hunt ID if successful, empty string otherwise
    """
    try:
        # Convert Sigma rules to string format
        sigma_rules_string = convert_sigma_rules_to_string(sigma_rules_dict, logger)
        if not sigma_rules_string:
            logger.error("Failed to convert Sigma rules to string format")
            return ""
            
        # Set artifact parameters
        artifact_name = "Windows.Sigma.EventLogs"
        
        # Set timeouts and resource limits
        timeout = general_settings.get("TimeForSigmaScanInSeconds", 600)
        expire_time = general_settings.get("TimeForSigmaScanInSeconds", 600)
        cpu_limit = general_settings.get("SigmaCpuLimit", 50)
        max_bytes_uploaded = general_settings.get("SigmaMaxBytesUploaded", 100000000)
        max_rows = general_settings.get("SigmaMaxRows", 1000000)
        
        # Set Sigma specific parameters
        event_log_directory = general_settings.get("EventLogDirectory", "C:/Windows/System32/WinEvt/Logs/")
        debug = general_settings.get("SigmaDebug", False)
        
        logger.info(f"Starting Windows.Sigma.EventLogs artifact with {timeout}s timeout")
        
        # Create artifact parameters
        params = {
            "EventLogDirectory": event_log_directory,
            "InlineSigmaRules": sigma_rules_string,
            "Debug": debug
        }
        
        # Format arguments according to your format
        arguments = format_arguments(params)
        
        # Create hunt query using exact format from the YARA code
        spec = f"dict(`{artifact_name}`=dict({arguments}))"
        query = f"LET collection = hunt(description='API Hunt:{artifact_name}', artifacts='{artifact_name}', spec={spec}, expires=now() + {expire_time}, timeout={timeout}, max_rows={max_rows}, max_bytes={max_bytes_uploaded}, cpu_limit={cpu_limit}) SELECT HuntId FROM collection"
        
        logger.info(f"Running query: {query}")
        
        # Setup connection
        channel = modules.Velociraptor.VelociraptorScript.setup_connection(logger)
        if not channel:
            logger.error("Failed to establish connection")
            return ""
            
        stub = api_pb2_grpc.APIStub(channel)
        
        # Run the hunt
        hunt_id, status, error = run_hunt(query, channel, stub, logger)
        
        # Close channel
        channel.close()
        
        if status == "Failed":
            logger.error(f"Failed to run Sigma scan: {error}")
            return ""
            
        return hunt_id
        
    except Exception as e:
        error_msg = f"Error running Windows.Sigma.EventLogs artifact: {str(e)}"
        logger.error(error_msg)
        logger.error(traceback.format_exc())
        return ""

def run_sigma_scan_with_file(general_settings, sigma_rule_file_path, logger):
    """
    Launches Windows.Sigma.EventLogs artifact using a file containing Sigma rules.
    
    Args:
        general_settings: Dictionary containing configuration settings
        sigma_rule_file_path: Path to the file containing Sigma rules
        logger: Logger object for logging messages
    
    Returns:
        str: Hunt ID if successful, empty string otherwise
    """
    try:
        # Set artifact parameters
        artifact_name = "Windows.Sigma.EventLogs"
        
        # Set timeouts and resource limits
        timeout = general_settings.get("TimeForSigmaScanInSeconds", 600)
        expire_time = general_settings.get("TimeForSigmaScanInSeconds", 600)
        cpu_limit = general_settings.get("SigmaCpuLimit", 50)
        max_bytes_uploaded = general_settings.get("SigmaMaxBytesUploaded", 100000000)
        max_rows = general_settings.get("SigmaMaxRows", 1000000)
        
        # Set Sigma specific parameters
        event_log_directory = general_settings.get("EventLogDirectory", "C:/Windows/System32/WinEvt/Logs/")
        debug = general_settings.get("SigmaDebug", False)
        
        logger.info(f"Starting Windows.Sigma.EventLogs artifact with {timeout}s timeout using rule file {sigma_rule_file_path}")
        
        # Create artifact parameters
        params = {
            "EventLogDirectory": event_log_directory,
            "SigmaRuleFile": sigma_rule_file_path,
            "Debug": debug
        }
        
        # Format arguments according to your format
        arguments = format_arguments(params)
        
        # Create hunt query using exact format from the YARA code
        spec = f"dict(`{artifact_name}`=dict({arguments}))"
        query = f"LET collection = hunt(description='API Hunt:{artifact_name}', artifacts='{artifact_name}', spec={spec}, expires=now() + {expire_time}, timeout={timeout}, max_rows={max_rows}, max_bytes={max_bytes_uploaded}, cpu_limit={cpu_limit}) SELECT HuntId FROM collection"
        
        logger.info(f"Running query: {query}")
        
        # Setup connection
        channel = modules.Velociraptor.VelociraptorScript.setup_connection(logger)
        if not channel:
            logger.error("Failed to establish connection")
            return ""
            
        stub = api_pb2_grpc.APIStub(channel)
        
        # Run the hunt
        hunt_id, status, error = run_hunt(query, channel, stub, logger)
        
        # Close channel
        channel.close()
        
        if status == "Failed":
            logger.error(f"Failed to run Sigma scan: {error}")
            return ""
            
        return hunt_id
        
    except Exception as e:
        error_msg = f"Error running Windows.Sigma.EventLogs artifact: {str(e)}"
        logger.error(error_msg)
        logger.error(traceback.format_exc())
        return ""

def run_sigma_scans(general_settings, sigma_rules_dict, current_date, logger):
    """
    Launches Sigma scan without waiting for results.
    
    Args:
        general_settings: Dictionary containing configuration settings
        sigma_rules_dict: Dictionary containing Sigma rules
        logger: Logger object for logging messages
    
    Returns:
        dict: Dictionary containing hunt ID for the launched scan
    """
    try:
        logger.info("Starting Sigma scan")
        logger.info("sigma object:" + str(sigma_rules_dict))
        
        # Run sigma scan
        hunt_id = run_sigma_scan(general_settings, sigma_rules_dict, logger)
        
        # Return hunt ID
        result = {
            "sigma_scan_hunt_id": hunt_id
        }
        
        logger.info(f"Sigma scan launched successfully")
        logger.info(f"Sigma scan hunt ID: {hunt_id}")
        with open(f"response_folder/response_ai_cve_management_sigma_{current_date}.json", "w") as f:
            json.dump(result, f, indent=4)
        return result
        
    except Exception as e:
        logger.error(f"Error launching Sigma scan: {str(e)}")
        logger.error(traceback.format_exc())
        return {"sigma_scan_hunt_id": ""}