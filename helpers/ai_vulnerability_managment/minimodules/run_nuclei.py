import subprocess
import os
import json
from datetime import datetime
import stat
import random

def extract_domains_with_nuclei(data):
    """
    Extracts domains that have Nuclei in their AssetModules list from the data object.
    
    Args:
        data (dict): Dictionary containing the assets data
        
    Returns:
        list: A list of dictionaries containing domain information
    """
    # Check if the expected structure exists
    if "ClientInfrastructure" not in data or "Assets" not in data["ClientInfrastructure"]:
        return "Error: JSON doesn't contain the expected structure"
    
    # Extract assets
    assets = data["ClientInfrastructure"]["Assets"]
    
    # Filter assets by type "Domain" and having "Nuclei" in AssetModules
    domains_with_nuclei = []
    
    for asset_id, asset_info in assets.items():
        if "AssetType" in asset_info and "Domain" in asset_info["AssetType"]:
            if "AssetModules" in asset_info and "Nuclei" in asset_info["AssetModules"]:
                domains_with_nuclei.append({
                    "asset_id": asset_id,
                    "asset_string": asset_info.get("AssetString", ""),
                    "enabled": bool(asset_info.get("AssetEnable", 0)),
                    "last_run_date": asset_info.get("LastRunDate", ""),
                    "asset_parent_id": asset_info.get("AssetParentId", ""),
                    "modules": asset_info.get("AssetModules", [])
                })
    
    return domains_with_nuclei

def create_include_severities(exclude_severity_list):
    all_severities = ["info", "low", "medium", "high", "critical", "unknown"]
    if exclude_severity_list:
        include_severity_list = [severity for severity in all_severities if severity not in exclude_severity_list]
        return include_severity_list
    return all_severities

def ensure_executable(file_path):
    if not os.path.isfile(file_path):
        raise FileNotFoundError(f"No such file or directory: '{file_path}'")
    
    # Check if the file is executable
    st = os.stat(file_path)
    if not st.st_mode & stat.S_IXUSR:
        os.chmod(file_path, st.st_mode | stat.S_IXUSR)
        print(f"Added execute permission to: {file_path}")

def run_nuclei_scan(data, current_date, logger):
    """
    Main function to extract domains with Nuclei and run Nuclei against them.
    
    Args:
        data (dict): Dictionary containing the assets data
        logger: Logger object for logging messages
        
    Returns:
        str: Path to the results file
    """
    try:
        # Extract domains that have Nuclei configured
        logger.info("Extracting domains with Nuclei configured...")
        domains = extract_domains_with_nuclei(data)
        
        if not domains:
            logger.error("No domains with Nuclei found")
            return None
            
        logger.info(f"Found {len(domains)} domains with Nuclei")
        
        # Create a list of domains for Nuclei targets
        population = []
        for domain in domains:
            if domain["enabled"]:
                population.append({
                    "asset_string": domain["asset_string"],
                    "asset_parent_id": domain["asset_parent_id"]
                })
                
        if not population:
            logger.error("No enabled domains found")
            return None
            
        logger.info(f"Using {len(population)} enabled domains as targets")
        
        # Create response folder if it doesn't exist
        if not os.path.exists("response_folder"):
            os.makedirs("response_folder")
            
        output_filename = f"response_folder/response_ai_cve_management_nuclei_{current_date}.json"
        
        # Set up Nuclei configuration
        current_working_directory = os.path.join(os.getcwd(), "modules", "Nuclei")
        nuclei_path = os.path.join(current_working_directory, "dependencies", "nuclei")
        nuclei_templates = os.path.join(current_working_directory, "dependencies/nuclei-templates/custom")
        nuclei_timeout = 1
        nuclei_include_severity = create_include_severities([])  # Include all severities
        
        # Ensure nuclei is executable
        try:
            ensure_executable(nuclei_path)
        except FileNotFoundError as e:
            logger.error(f"Nuclei executable not found: {str(e)}")
            return None
        
        # Create targets file
        targets_list = [asset['asset_string'] for asset in population]
        nuclei_list_path = 'nuclei_list.txt'
        with open(nuclei_list_path, 'w') as file:
            for target in targets_list:
                file.write(f"{target}\n")
        
        # Build and execute Nuclei command
        command = [
            nuclei_path, 
            "-list", nuclei_list_path, 
            "-json-export", output_filename, 
            "-timeout", str(nuclei_timeout), 
            "-mhe", "1", 
            "-severity", ",".join(nuclei_include_severity)
        ]
        
        if nuclei_templates:
            command.extend(["-templates", nuclei_templates])
            
        command.append("-vv")  # Verbose mode
        
        logger.info(f"Executing Nuclei command: {' '.join(command)}")
        
        # Run Nuclei command
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        
        # Read output line by line
        while True:
            output_line = process.stdout.readline()
            if output_line == '' and process.poll() is not None:
                break
            if output_line:
                logger.info(output_line.strip())
        
        if process.returncode != 0:
            logger.error(f"Nuclei command exited with error code: {process.returncode}")
        
        logger.info(f"Nuclei scan completed. Results saved to {output_filename}")
        """
        # Add timestamp to the results
        if os.path.exists(output_filename):
            try:
                with open(output_filename, 'r') as f:
                    data = json.load(f)
                
                for obj in data:
                    obj["@timestamp"] = datetime.utcnow().isoformat(timespec='milliseconds') + 'Z'
                    # Match asset parent ID
                    hostname = obj.get("host")
                    if hostname:
                        for asset in population:
                            if asset["asset_string"] == hostname:
                                obj["asset_string"] = hostname
                                obj["asset_parent_id"] = asset["asset_parent_id"]
                                break
                
                logger.info(f"Added timestamps and asset information to results")
            except Exception as e:
                logger.error(f"Error processing results file: {str(e)}")
        
        return output_filename
        """
        
    except Exception as e:
        logger.error(f"Error in nuclei_run_for_domains: {str(e)}")
        return None

# Example usage:
# nuclei_run_for_domains(data_object, logger)