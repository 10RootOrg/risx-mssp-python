
import os
import sys
import json
import traceback

# Get the absolute path of this script
script_path = os.path.abspath(__file__)
script_dir = os.path.dirname(script_path)
main_dir = os.path.abspath(os.path.join(script_dir, "../.."))
os.chdir(main_dir)
sys.path.insert(0, main_dir)
print(f"Current Working Directory: {os.getcwd()}")

import additionals.mysql_functions
import openai
import additionals.logger
import additionals.funcs
import additionals.elastic_api
import helpers.ai_vulnerability_managment.nvd_api_functions
import helpers.ai_vulnerability_managment.gpt_api
import helpers.ai_vulnerability_managment.alerts
from datetime import datetime, timedelta

general_settings = {
    "GPT_GPT_API_KEY": "",  # Replace with your actual API key
    "NVD_GPT_API_KEY": "",
    "MODEL": "gpt-4o-search-preview",
    "PRODUCTS": [],
    "MAX_TOKENS": 4096,  # Ensure model can accept a lot of tokens
    "MIN_CVSS_SCORE": 8,
    "PROMPT": "",
    "FromTheFollowingTime": "1",
    "SYSTEM_PROMPT": """prompt""",
    "JSON_OUTPUT_PATH": os.path.join("response_folder", "CVE_AI_MANAGMENT_RESULTS.json")
}
def setup_global_variables(general_settings, config, logger):
    try:
        general_settings["GPT_API_KEY"] = config.get('ClientData', {}).get('API', {}).get('AiManagement', '')
        if not general_settings["GPT_API_KEY"]:
            logger.warning("GPT API key not found in configuration")
            
        general_settings["NVD_API_KEY"] = config.get('ClientData', {}).get('API', {}).get('NVD', '')
        if not general_settings["NVD_API_KEY"]:
            logger.warning("NVD API key not found in configuration")

        ai_config = config.get("General", {}).get("IntervalConfigurations", {}).get("AiManagement", {})
        if not ai_config:
            logger.warning("AiManagement configuration not found")
            ai_config = {}
            
        if ai_config.get("MODEL"):
            general_settings["MODEL"] = ai_config["MODEL"]
        if ai_config.get("MAX_TOKENS"):
            general_settings["MAX_TOKENS"] = ai_config["MAX_TOKENS"]
        if ai_config.get("MIN_CVSS_SCORE"):
            general_settings["MIN_CVSS_SCORE"] = ai_config["MIN_CVSS_SCORE"]
        if ai_config.get("PROMPT"):
            general_settings["PROMPT"] = ai_config["PROMPT"]
        if ai_config.get("PRODUCTS"):
            general_settings["PRODUCTS"] = ai_config["PRODUCTS"]
        if ai_config.get("FromTheFollowingTime"):
            general_settings["FromTheFollowingTime"] = ai_config["FromTheFollowingTime"]

        if not (general_settings["PRODUCTS"]):
            logger.info("Give all data from the date provided")
        # Safely handle string replacements
        safe_min_cvss = str(general_settings["MIN_CVSS_SCORE"])
        safe_products = ", ".join(general_settings["PRODUCTS"]) if general_settings["PRODUCTS"] else "No products specified"
        
        general_settings["PROMPT"] = general_settings["PROMPT"].replace("min-cvss-score_to_check_in_prompt", safe_min_cvss)
        general_settings["PROMPT"] = general_settings["PROMPT"].replace("products_to_check_in_prompt", safe_products)
        general_settings["PROMPT"] = general_settings["PROMPT"].replace("from_time_to_check_in_prompt", general_settings["FromTheFollowingTime"])
        return general_settings
    except Exception as e:
        logger.error(f"Error in setup_global_variables: {str(e)}")
        # Set some defaults to prevent crashes
        if not general_settings["GPT_API_KEY"]:
            logger.critical("No API key available - functionality will be limited")

def nvd_func_calls(general_settings, products_cpe_dict, logger):
    """
    Call the NVD API function and handle the dictionary result.
    
    Parameters:
        general_settings (dict): Application settings
        products_cpe_dict (dict): Dictionary of product names to CPE strings
        logger: Logger object
        
    Returns:
        dict: Dictionary of vulnerabilities, or empty dict if none found
    """
    # Example parameters
    max_vulnerabilities = 1000
    start_date = (datetime.now() - timedelta(days=int(general_settings["FromTheFollowingTime"]))).strftime("%Y-%m-%d")
    
    # Get vulnerabilities - now returns a dictionary, not a DataFrame
    result = helpers.ai_vulnerability_managment.nvd_api_functions.get_cves_from_nvd(
        max_vulnerabilities=max_vulnerabilities,
        start_date=start_date,
        cpe_dict=products_cpe_dict,
        min_cvss_score=general_settings["MIN_CVSS_SCORE"],
        api_key=general_settings["NVD_API_KEY"],
        logger=logger
    )
    
    # Display summary
    if result and "vulnerabilities" in result and len(result["vulnerabilities"]) > 0:
        num_vulns = len(result["vulnerabilities"])
        logger.info(f"Found {num_vulns} vulnerabilities")
        
        # Export to JSON file
        try:
            output_json_file = os.path.join("response_folder", "nvd_vulnerabilities_before_AI.json")
            with open(output_json_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            logger.info(f"JSON results exported to {output_json_file}")
        except Exception as e:
            logger.error(f"Error exporting results: {str(e)}")
    else:
        logger.info("No vulnerabilities found matching the criteria")
        # Initialize an empty result if none was returned
        if not result:
            result = {"vulnerabilities": {}}
    
    # Always return the result, even if empty
    return result

def get_config(logger):
    try:
        env_dict = additionals.funcs.read_env_file(logger)
    except Exception as e:
        logger.error(f"Error reading environment file: {str(e)}")
        env_dict = {}
        
    try:
        connection = additionals.mysql_functions.setup_mysql_connection(env_dict, logger)
        query_result = additionals.mysql_functions.execute_query(connection, "SELECT config FROM configjson LIMIT 1", logger)
        
        if query_result and query_result[0] and query_result[0][0]:
            config_data = json.loads(query_result[0][0])
            return config_data
        else:
            logger.error("No configuration data retrieved from database")
            config_data = {}
    except Exception as e:
        logger.error(f"Error connecting to database or retrieving config: {str(e)}")
        config_data = {}
if __name__ == "__main__":
    try:
        
        logger = additionals.logger.setup_logger("alerts_vuln_cve_managment_helper.log")
        if(os.path.exists(general_settings["JSON_OUTPUT_PATH"])):
            os.remove(general_settings["JSON_OUTPUT_PATH"])

        config_data = get_config(logger)
        general_settings = setup_global_variables(general_settings, config_data, logger)
        gpt_client = helpers.ai_vulnerability_managment.gpt_api.create_api_connection(general_settings, logger)
        products_cpe_dict = helpers.ai_vulnerability_managment.gpt_api.products_list_to_cpe_dict(gpt_client, general_settings, general_settings["PRODUCTS"], logger)
        logger.info("cpe_dict:" + str(products_cpe_dict))
        json_before_ai = nvd_func_calls(general_settings, products_cpe_dict, logger)

        final_json = helpers.ai_vulnerability_managment.gpt_api.enrich_cve_data(gpt_client, json_before_ai, general_settings, logger)
        final_json = {k: v for k, v in final_json["vulnerabilities"].items()}
        logger.info("final json:" + str(final_json))
        if final_json:
            with open(general_settings["JSON_OUTPUT_PATH"], 'w', encoding='utf-8') as f:
                json.dump(final_json, f, indent=2, ensure_ascii=False)
            elasticIp=config_data['ClientData']['API']['Elastic']["Ip"]
            additionals.elastic_api.enter_data(general_settings["JSON_OUTPUT_PATH"], "agentic_ai_vulnerability_management",elasticIp, logger)
            helpers.ai_vulnerability_managment.alerts.add_new_alerts(final_json, logger)
        else:
            logger.error(f"There is nothing in final_json")

    except Exception as e:
        logger.info("General error:" + str(e))