#!/usr/bin/env python3
import os
import sys

# Get the absolute path of this script
script_path = os.path.abspath(__file__)
script_dir = os.path.dirname(script_path)
main_dir = os.path.abspath(os.path.join(script_dir, "../.."))
os.chdir(main_dir)
sys.path.insert(0, main_dir)
print(f"Current Working Directory: {os.getcwd()}")

import openai
import json
import additionals.logger

# Configuration Variables
API_KEY = ""  # Replace with your actual API key
MODEL = "gpt-4-turbo"  # Or "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo"

MAX_TOKENS = 4096  # Ensure model can accept a lot of tokens
PROMPT = """Retrieve CVEs from the past month with a CVSS score above 8 that are relevant to the following devices:
Windows 11, CrowdStrike Falcon, Linux Ubuntu
Return the data in JSON format with a maximum of 3 CVEs per response. If there are more than 3 CVEs available, prepend true before the JSON; otherwise, prepend false.

Each CVE entry should have the following fields:

CVE ID – The identifier of the CVE
CVSS Score – The severity rating
Affected Device – The impacted system
YARA Rule – A YARA rule for detecting the vulnerability
Sigma Rule – A Sigma rule for detecting the vulnerability
Mitigation Tips – Recommended actions to mitigate the vulnerability
Generate YARA and Sigma rules specific to each CVE. Return only the JSON without additional explanations."""

current_cve_index = 0
all_cves = []
client = openai.OpenAI(api_key=API_KEY)  # Initialize the client
def query_gpt():
    """Send prompt to GPT and retrieve the CVEs."""
    response = client.chat.completions.create(
        model=MODEL,
        messages=[
            {"role": "system", "content": "You are an expert in cybersecurity providing CVE details."},
            {"role": "user", "content": PROMPT}
        ],
        max_tokens=MAX_TOKENS
    )
    return response.choices[0].message.content

def parse_response(response_text):
    """Parse the response and extract CVEs."""
    global all_cves
    if response_text.startswith("true"):
        json_data = response_text[4:].strip()
        prepend_true = True
    else:
        json_data = response_text[5:].strip()
        prepend_true = False
    
    cve_list = json.loads(json_data)
    all_cves.extend(cve_list)
    return prepend_true

def get_next_cves():
    """Retrieve the next batch of CVEs."""
    global current_cve_index, all_cves
    if current_cve_index < len(all_cves):
        next_cves = all_cves[current_cve_index:current_cve_index + 3]
        current_cve_index += 3
        prepend_true = True if current_cve_index < len(all_cves) else False
    else:
        response_text = query_gpt()
        prepend_true = parse_response(response_text)
        next_cves = all_cves[current_cve_index:current_cve_index + 3]
        current_cve_index += 3
    
    return prepend_true, json.dumps(next_cves, indent=4)

if __name__ == "__main__":
    logger = additionals.funcs.setup_logger("alerts_helper.log")
    prepend_true, cve_json = get_next_cves()
    logger.info("true" if prepend_true else "false")
    logger.info(cve_json)
