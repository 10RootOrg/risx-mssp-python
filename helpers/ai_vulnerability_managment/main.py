import os
import sys
import json
import traceback

# Get the absolute path of this script
script_path = os.path.abspath(__file__)
script_dir = os.path.dirname(script_path)
main_dir = os.path.abspath(os.path.join(script_dir, "../.."))
os.chdir(main_dir)
sys.path.insert(0, main_dir)
print(f"Current Working Directory: {os.getcwd()}")


import openai
import additionals.elastic_api
import helpers.ai_vulnerability_managment.nvd_api_functions
import helpers.ai_vulnerability_managment.gpt_api
import helpers.ai_vulnerability_managment.alerts
import helpers.ai_vulnerability_managment.auto_products_detection
from datetime import datetime, timedelta
import helpers.ai_vulnerability_managment.seperate_rules
import helpers.ai_vulnerability_managment.global_variables
import helpers.ai_vulnerability_managment.minimodules.run_yara
import helpers.ai_vulnerability_managment.minimodules.run_sigma
import helpers.ai_vulnerability_managment.minimodules.run_nuclei
import helpers.ai_vulnerability_managment.helpers.logger_helper
general_settings = {
    "GPT_GPT_API_KEY": "",  # Replace with your actual API key
    "NVD_GPT_API_KEY": "",
    "MODEL": "gpt-4o-search-preview",
    "PRODUCTS": [],
    "MAX_TOKENS": 4096,  # Ensure model can accept a lot of tokens
    "MIN_CVSS_SCORE": 8,
    "PROMPT": "",
    "FromTheFollowingTime": "1",
    "SYSTEM_PROMPT": """prompt""",
    "JSON_OUTPUT_PATH": os.path.join("response_folder", "CVE_AI_MANAGMENT_RESULTS.json")
}



import threading
from concurrent.futures import ThreadPoolExecutor
from threading import Lock

def run_concurrent_scans(general_settings, config_data, yara_rules, sigma_rules, logger):
    # Dictionary to store results from all scans
    results = {
        "yara_results": None,
        "sigma_results": None,
        "nuclei_results": None
    }
    shared_lock = Lock()  # For thread-safe updates to shared data structures
    
    # Generate unique IDs for each scan
    import random
    yara_id = str(random.randint(10000000, 99999999))
    sigma_id = str(random.randint(10000000, 99999999))
    nuclei_id = str(random.randint(10000000, 99999999))
    
    # Generate current datetime in the format used in the config
    from datetime import datetime
    current_date = datetime.now().strftime("%d-%m-%Y-%H-%M-%S")
    expire_date = datetime.now().strftime("%Y-%m-%d") + "T" + datetime.now().strftime("%H:%M:%S")
    
    # Wrapper functions to capture return values
    def run_yara_wrapper():
        result = helpers.ai_vulnerability_managment.minimodules.run_yara.run_yara_scans(
            general_settings, yara_rules, current_date, logger
        )
        with shared_lock:
            results["yara_results"] = result
            
            # Add to RequestStatus in config_data
            scan_entry = {
                "Error": "",
                "Status": "Complete",
                "UniqueID": yara_id,
                "Arguments": "",
                "StartDate": current_date,
                "ExpireDate": expire_date,
                "ModuleName": "Yara AI",
                "Population": config_data.get("ClientData", {}).get("Population", []),
                "ResponsePath": f"response_folder/response_ai_cve_management_yara_{current_date}.json",
                "TimeInterval": "",
                "SubModuleName": "",
                "LastIntervalDate": current_date,
                "ArtifactTimeOutInMinutes": ""
            }
            config_data["RequestStatus"].append(scan_entry)
    
    def run_sigma_wrapper():
        result = helpers.ai_vulnerability_managment.minimodules.run_sigma.run_sigma_scans(
            general_settings, sigma_rules, current_date, logger
        )
        with shared_lock:
            results["sigma_results"] = result
            
            # Add to RequestStatus in config_data
            scan_entry = {
                "Error": "",
                "Status": "Complete",
                "UniqueID": sigma_id,
                "Arguments": "",
                "StartDate": current_date,
                "ExpireDate": expire_date,
                "ModuleName": "Sigma AI",
                "Population": config_data.get("ClientData", {}).get("Population", []),
                "ResponsePath": f"response_folder/response_ai_cve_management_sigma_{current_date}.json",
                "TimeInterval": "",
                "SubModuleName": "",
                "LastIntervalDate": current_date,
                "ArtifactTimeOutInMinutes": ""
            }
            config_data["RequestStatus"].append(scan_entry)
    
    def run_nuclei_wrapper():
        result = helpers.ai_vulnerability_managment.minimodules.run_nuclei.run_nuclei_scan(
            config_data, current_date, logger
        )
        with shared_lock:
            results["nuclei_results"] = result
            
            # Add to RequestStatus in config_data
            scan_entry = {
                "Error": "",
                "Status": "Complete",
                "UniqueID": nuclei_id,
                "Arguments": {
                    "NucleiTags": "",
                    "NucleiWorkflow": "",
                    "NucleiArgumentFlags": [],
                    "NucleiExcludeSeverity": []
                },
                "StartDate": current_date,
                "ExpireDate": expire_date,
                "ModuleName": "Nuclei AI",
                "Population": config_data.get("ClientData", {}).get("Population", []),
                "ResponsePath": f"response_folder/response_ai_cve_management_nuclei_{current_date}.json",
                "TimeInterval": "",
                "SubModuleName": "",
                "LastIntervalDate": current_date,
                "ArtifactTimeOutInMinutes": ""
            }
            config_data["RequestStatus"].append(scan_entry)
    
    threads = []
    
    if general_settings["RunYara"] == "true":
        logger.info("Running Yara")
        yara_thread = threading.Thread(target=run_yara_wrapper)
        threads.append(yara_thread)
    
    if general_settings["RunSigma"] == "true":
        logger.info("Running Sigma")
        sigma_thread = threading.Thread(target=run_sigma_wrapper)
        threads.append(sigma_thread)
    
    if general_settings["RunNuclei"] == "true":
        logger.info("Running Nuclei")
        nuclei_thread = threading.Thread(target=run_nuclei_wrapper)
        threads.append(nuclei_thread)
    
    # Start all threads
    for thread in threads:
        thread.start()
    
    # Wait for all threads to complete
    for thread in threads:
        thread.join()
    
    # Return the collected results
    
    return config_data

if __name__ == "__main__":
    try:
        
        logger = helpers.ai_vulnerability_managment.helpers.logger_helper.setup_logger("alerts_vuln_cve_managment_helper.log", log_to_stdout=True)
        prompt_logger = helpers.ai_vulnerability_managment.helpers.logger_helper.setup_logger("cve_managment_prompt.log", log_to_stdout=False, clean_format=True)
        env_dict = additionals.funcs.read_env_file(logger)
        previous_config_date = datetime.now().strftime('%d-%m-%Y-%H-%M-%S')
        if(os.path.exists(general_settings["JSON_OUTPUT_PATH"])):
            os.remove(general_settings["JSON_OUTPUT_PATH"])

        config_data = helpers.ai_vulnerability_managment.global_variables.get_config(logger)
        general_settings = helpers.ai_vulnerability_managment.global_variables.setup_global_variables(general_settings, config_data, logger)
        products_list = []

        if(general_settings["AutoProductsDetection"] == "true"):
            # Wrap this specific call in a try-except to isolate error if it happens here
            try:
                products_list = helpers.ai_vulnerability_managment.auto_products_detection.get_products_auto(general_settings, logger)
            except Exception as e:
                logger.error(f"Error in auto product detection: {str(e)}")
                logger.error(f"Traceback: {traceback.format_exc()}")
                # Continue execution with empty product list
                products_list = []
                
        products_list = products_list + general_settings["PRODUCTS"]
        gpt_client = helpers.ai_vulnerability_managment.gpt_api.create_api_connection(general_settings, logger)
        products_cpe_dict = helpers.ai_vulnerability_managment.gpt_api.products_list_to_cpe_dict(gpt_client, general_settings, products_list, logger, prompt_logger)
        logger.info("cpe_dict:" + str(products_cpe_dict))
        json_before_ai = helpers.ai_vulnerability_managment.nvd_api_functions.nvd_func_calls(general_settings, products_cpe_dict, logger)

        final_json = helpers.ai_vulnerability_managment.gpt_api.enrich_cve_data(gpt_client, json_before_ai, general_settings, logger, prompt_logger)
        #final_json = {k: v for k, v in final_json["vulnerabilities"].items()}
        logger.info("final json:" + str(final_json))
        if final_json:
            with open(general_settings["JSON_OUTPUT_PATH"], 'w', encoding='utf-8') as f:
                json.dump(final_json, f, indent=2, ensure_ascii=False)
            sigma_rules, nuclei_rules, yara_rules = helpers.ai_vulnerability_managment.seperate_rules.extract_rules(final_json, logger)
            elasticIp=config_data['ClientData']['API']['Elastic']["Ip"]
            additionals.elastic_api.enter_data(general_settings["JSON_OUTPUT_PATH"], "agentic_ai_vulnerability_management",elasticIp, logger)
            helpers.ai_vulnerability_managment.alerts.add_new_alerts(final_json, logger)

            config_data = run_concurrent_scans(general_settings, config_data, yara_rules, sigma_rules, logger)
            additionals.funcs.connect_db_update_config(env_dict, previous_config_date, config_data, logger)
        else:
            logger.error(f"There is nothing in final_json")
        
    except Exception as e:
        # Log the full traceback for detailed error information
        error_traceback = traceback.format_exc()
        logger.error(f"General error: {str(e)}")
        logger.error(f"Error traceback: {error_traceback}")
        
        # You can also print to console for immediate feedback
        print(f"ERROR: {str(e)}")
        print(f"TRACEBACK: {error_traceback}")