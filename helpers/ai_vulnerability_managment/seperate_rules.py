import json
import os
import re
import yaml
from collections import defaultdict

def create_nuclei_yaml_files(nuclei_rules, logger):
    """
    Creates individual YAML files for Nuclei rules extracted from CVE data.
    
    Args:
        nuclei_rules (dict): Dictionary containing Nuclei rules indexed by CVE ID
        logger: Logger object for logging messages
    """
    output_dir = os.path.join("modules", "Nuclei", "dependencies", "nuclei-templates")
    
    try:
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Counter for created files
        files_created = 0
        
        # Process each CVE and its associated rules
        for cve_id, rules in nuclei_rules.items():
            if not rules:
                continue
            
            # Process each rule for this CVE
            for i, rule in enumerate(rules):
                try:
                    # Determine the appropriate category based on this specific rule
                    template_dir = os.path.join(output_dir, "custom")
                    
                    # Create directory
                    try:
                        os.makedirs(template_dir, exist_ok=True)
                    except (PermissionError, OSError) as e:
                        if logger:
                            logger.error(f"Failed to create directory {template_dir}: {str(e)}")
                        continue
                    
                    # Extract basic information for filename
                    rule_id = rule.get("id", "")
                    name = rule.get("info", {}).get("name", "")
                    
                    # Create a clean filename
                    if rule_id:
                        # Use rule_id if available
                        filename = re.sub(r'[^\w\-\.]', '', re.sub(r'\s+', '_', rule_id))[:255]
                    elif name:
                        # Use name if no rule_id
                        filename = re.sub(r'[^\w\-\.]', '', re.sub(r'\s+', '_', name))[:255]
                    else:
                        # Use index if neither is available
                        filename = f"{cve_id}-rule-{i+1}"
                    
                    # Ensure filename has .yaml extension
                    if not filename.endswith('.yaml'):
                        filename = f"{filename}.yaml"
                    
                    # Create full file path
                    file_path = os.path.join(template_dir, filename)
                    
                    # Format the rule as YAML
                    yaml_content = yaml.safe_dump(rule, sort_keys=False, default_flow_style=False)
                    
                    # Write the YAML file
                    with open(file_path, 'w') as f:
                        f.write(yaml_content)
                    
                    files_created += 1
                    
                    if logger:
                        logger.info(f"Created Nuclei rule: {file_path}")
                    
                except Exception as e:
                    if logger:
                        logger.error(f"Error creating YAML for {cve_id}, rule index {i}: {str(e)}")
        
        # Log completion if logger is provided
        if logger:
            logger.info(f"Completed creation of {files_created} Nuclei YAML files")
    
    except Exception as e:
        if logger:
            logger.error(f"Unexpected error during YAML creation: {str(e)}")

def create_mitigations_yaml_files(mitigations_data, logger):
    """
    Creates individual YAML files for mitigations extracted from CVE data.
    
    Args:
        mitigations_data (dict): Dictionary containing mitigations indexed by CVE ID
        logger: Logger object for logging messages
    """
    output_dir = os.path.join("modules", "Mitigations", "dependencies", "mitigations-templates")
    
    try:
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Counter for created files
        files_created = 0
        
        # Process each CVE and its associated mitigations
        for cve_id, mitigation in mitigations_data.items():
            if not mitigation:
                continue
            
            try:
                # Create a clean filename
                filename = f"{cve_id}-mitigations.yaml"
                
                # Create full file path
                file_path = os.path.join(output_dir, filename)
                
                # Format the mitigation as YAML
                yaml_content = yaml.safe_dump(mitigation, sort_keys=False, default_flow_style=False)
                
                # Write the YAML file
                with open(file_path, 'w') as f:
                    f.write(yaml_content)
                
                files_created += 1
                
                if logger:
                    logger.info(f"Created Mitigation file: {file_path}")
                
            except Exception as e:
                if logger:
                    logger.error(f"Error creating YAML for {cve_id} mitigations: {str(e)}")
        
        # Log completion if logger is provided
        if logger:
            logger.info(f"Completed creation of {files_created} Mitigations YAML files")
    
    except Exception as e:
        if logger:
            logger.error(f"Unexpected error during mitigations YAML creation: {str(e)}")

def create_known_exploits_yaml_files(known_exploits_data, logger):
    """
    Creates individual YAML files for known exploits extracted from CVE data.
    
    Args:
        known_exploits_data (dict): Dictionary containing known exploits indexed by CVE ID
        logger: Logger object for logging messages
    """
    output_dir = os.path.join("modules", "KnownExploits", "dependencies", "known-exploits-templates")
    
    try:
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Counter for created files
        files_created = 0
        
        # Process each CVE and its associated known exploits
        for cve_id, exploit in known_exploits_data.items():
            if not exploit:
                continue
            
            try:
                # Create a clean filename
                filename = f"{cve_id}-known-exploits.yaml"
                
                # Create full file path
                file_path = os.path.join(output_dir, filename)
                
                # Format the exploit data as YAML
                yaml_content = yaml.safe_dump(exploit, sort_keys=False, default_flow_style=False)
                
                # Write the YAML file
                with open(file_path, 'w') as f:
                    f.write(yaml_content)
                
                files_created += 1
                
                if logger:
                    logger.info(f"Created Known Exploit file: {file_path}")
                
            except Exception as e:
                if logger:
                    logger.error(f"Error creating YAML for {cve_id} known exploits: {str(e)}")
        
        # Log completion if logger is provided
        if logger:
            logger.info(f"Completed creation of {files_created} Known Exploits YAML files")
    
    except Exception as e:
        if logger:
            logger.error(f"Unexpected error during known exploits YAML creation: {str(e)}")

def extract_rules(json_data, logger):
    """
    Extracts Sigma, Nuclei, YARA rules, Mitigations, and Known Exploits from CVE data 
    and saves them to predefined locations.
    If files already exist, loads them and merges new data to avoid duplications.
    
    Args:
        json_data (dict): The JSON data containing CVE information
        logger: Logger object for logging messages
        
    Returns:
        tuple: Five dictionaries containing Sigma, Nuclei, YARA rules, Mitigations, and Known Exploits
    """
    sigma_rules = {}
    nuclei_rules = {}
    yara_rules = {}
    mitigations_data = {}
    known_exploits_data = {}
    output_folder = "response_folder"
    
    logger.info("Starting extraction of rules and data")
    
    # Extract rules and data from each CVE
    for cve_id, cve_data in json_data.items():
        if "sigma_rules" in cve_data and cve_data["sigma_rules"]:
            sigma_rules[cve_id] = cve_data["sigma_rules"]
        
        if "nuclei_rules" in cve_data and cve_data["nuclei_rules"]:
            nuclei_rules[cve_id] = cve_data["nuclei_rules"]
        
        if "yara_rules" in cve_data and cve_data["yara_rules"]:
            yara_rules[cve_id] = cve_data["yara_rules"]
        
        if "mitigations" in cve_data and cve_data["mitigations"]:
            mitigations_data[cve_id] = cve_data["mitigations"]
        
        if "known_exploits" in cve_data and cve_data["known_exploits"]:
            known_exploits_data[cve_id] = cve_data["known_exploits"]
    
    # Create YAML files for each type of data
    create_nuclei_yaml_files(nuclei_rules, logger)
    # create_mitigations_yaml_files(mitigations_data, logger)
    # create_known_exploits_yaml_files(known_exploits_data, logger)
    
    # Create output directory if it doesn't exist
    os.makedirs(output_folder, exist_ok=True)
    
    # File paths
    sigma_path = f"{output_folder}/sigma_rules.json"
    nuclei_path = f"{output_folder}/nuclei_rules.json"
    yara_path = f"{output_folder}/yara_rules.json"
    mitigations_path = f"{output_folder}/mitigations.json"
    known_exploits_path = f"{output_folder}/known_exploits.json"
    
    # Load existing files and merge data
    try:
        # Process Sigma rules
        if os.path.exists(sigma_path):
            with open(sigma_path, 'r') as f:
                existing_sigma = json.load(f)
                logger.info(f"Loaded existing Sigma rules: {len(existing_sigma)} CVEs")
                for cve_id, rules in sigma_rules.items():
                    if cve_id in existing_sigma:
                        # Check for duplicates before appending
                        existing_ids = set()
                        for rule in existing_sigma[cve_id]:
                            rule_id = rule.get('id', '')
                            existing_ids.add(rule_id)
                        
                        for rule in rules:
                            rule_id = rule.get('id', '')
                            if rule_id and rule_id not in existing_ids:
                                existing_sigma[cve_id].append(rule)
                                existing_ids.add(rule_id)
                            elif not rule_id:  # If no ID exists, just append
                                existing_sigma[cve_id].append(rule)
                    else:
                        existing_sigma[cve_id] = rules
                sigma_rules = existing_sigma
        
        # Process Nuclei rules
        if os.path.exists(nuclei_path):
            with open(nuclei_path, 'r') as f:
                existing_nuclei = json.load(f)
                logger.info(f"Loaded existing Nuclei rules: {len(existing_nuclei)} CVEs")
                for cve_id, rules in nuclei_rules.items():
                    if cve_id in existing_nuclei:
                        # Check for duplicates before appending
                        existing_ids = set()
                        for rule in existing_nuclei[cve_id]:
                            rule_id = rule.get('id', '')
                            existing_ids.add(rule_id)
                        
                        for rule in rules:
                            rule_id = rule.get('id', '')
                            if rule_id and rule_id not in existing_ids:
                                existing_nuclei[cve_id].append(rule)
                                existing_ids.add(rule_id)
                            elif not rule_id:  # If no ID exists, just append
                                existing_nuclei[cve_id].append(rule)
                    else:
                        existing_nuclei[cve_id] = rules
                nuclei_rules = existing_nuclei
        
        # Process YARA rules
        if os.path.exists(yara_path):
            with open(yara_path, 'r') as f:
                existing_yara = json.load(f)
                logger.info(f"Loaded existing YARA rules: {len(existing_yara)} CVEs")
                for cve_id, rules in yara_rules.items():
                    if cve_id in existing_yara:
                        # Check for duplicates before appending
                        existing_rules = set()
                        for rule in existing_yara[cve_id]:
                            rule_name = rule.get('rule', '')
                            existing_rules.add(rule_name)
                        
                        for rule in rules:
                            rule_name = rule.get('rule', '')
                            if rule_name and rule_name not in existing_rules:
                                existing_yara[cve_id].append(rule)
                                existing_rules.add(rule_name)
                            elif not rule_name:  # If no name exists, just append
                                existing_yara[cve_id].append(rule)
                    else:
                        existing_yara[cve_id] = rules
                yara_rules = existing_yara

        # Process Mitigations
        if os.path.exists(mitigations_path):
            with open(mitigations_path, 'r') as f:
                existing_mitigations = json.load(f)
                logger.info(f"Loaded existing Mitigations: {len(existing_mitigations)} CVEs")
                # For mitigations, we'll just replace existing ones with new ones if they exist
                for cve_id, mitigation in mitigations_data.items():
                    existing_mitigations[cve_id] = mitigation
                mitigations_data = existing_mitigations
        
        # Process Known Exploits
        if os.path.exists(known_exploits_path):
            with open(known_exploits_path, 'r') as f:
                existing_known_exploits = json.load(f)
                logger.info(f"Loaded existing Known Exploits: {len(existing_known_exploits)} CVEs")
                # For known exploits, we'll just replace existing ones with new ones if they exist
                for cve_id, exploit in known_exploits_data.items():
                    existing_known_exploits[cve_id] = exploit
                known_exploits_data = existing_known_exploits
    
    except Exception as e:
        logger.error(f"Error loading existing rules or data: {e}")
    
    # Save the merged rules and data
    try:
        with open(sigma_path, 'w') as f:
            json.dump(sigma_rules, f, indent=2)
        
        with open(nuclei_path, 'w') as f:
            json.dump(nuclei_rules, f, indent=2)
        
        with open(yara_path, 'w') as f:
            json.dump(yara_rules, f, indent=2)
        
        with open(mitigations_path, 'w') as f:
            json.dump(mitigations_data, f, indent=2)
        
        with open(known_exploits_path, 'w') as f:
            json.dump(known_exploits_data, f, indent=2)
        
        logger.info(f"Rules and data saved to {output_folder}")
    except Exception as e:
        logger.error(f"Error saving rules or data: {e}")
    
    return sigma_rules, nuclei_rules, yara_rules, mitigations_data, known_exploits_data