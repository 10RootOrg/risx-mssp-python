import openai
import re
import time
import json
from json_repair import repair_json

MAX_TOKENS = 4096  # Ensure model can accept a lot of tokens
def extract_json_from_gpt_old(response):
    json_match = re.search(r'\{.*\}', response, re.DOTALL)
    if json_match:
        json_text = json_match.group(0).strip()
        return json.loads(json_text)
    else:
        raise ValueError("No valid JSON object found in response.")
    
def extract_json_from_gpt(text):
    # Try to find JSON object within the response, even if surrounded by markdown or other text
    pattern = r'(?s)^.*?(\{.*\}).*$'  # Match JSON object inside the text
    match = re.search(pattern, text)
    if match:
        try:
            json_text = match.group(1)
            return json.loads(json_text)
        except json.JSONDecodeError:
            return None
    return None

# CPE PROMPT
def products_list_to_cpe_dict_other(client, general_settings, product_list, logger):
    formatted_products = json.dumps(product_list, indent=2)
    prompt = f"""
    Given the following software names (with optional versions):
    {formatted_products}

    Provide a serialized JSON object mapping each software to its exact standardized CPE (Common Platform Enumeration) identifier, ensuring compatibility with the NVD database.

    ### General Rules for CPE Selection:
    1. **Use Exact Official CPEs**
    - Match software names and versions to their **precise** CPE entries as listed in the NVD database.
    - If multiple versions exist, prioritize the **most widely-used** or **most recent version with vulnerabilities**.

    2. **Handling Versions & Variants**
    - If a version is given, use it **only if it exists in NVD**.
    - If a version includes **unofficial labels** (e.g., `"latest"`, `"H2"`, `"24H2"`), replace them with the closest official release.
    - If no version is provided, return the **most stable release with known vulnerabilities**.

    3. **Windows & Operating Systems**
    - For **Windows versions**, ensure the CPE includes the correct **major version and edition**.
    - Prefer broader Windows CPEs (`windows_10:*`, `windows_server_2016:*`) to capture more vulnerabilities.
    - If the exact version isn't found, use the most common **wildcarded CPE** to match multiple versions.

    4. **Applications & Third-Party Software**
    - Use the **recognized vendor name** from NVD (e.g., `"adobe"` for Acrobat Reader).
    - Ensure the CPE reflects the **most relevant product line** (e.g., `"anydesk:anydesk"` instead of `"philandro:anydesk"` if required).

    5. **Hardware & Network Devices**
    - For firmware-based devices (routers, switches, etc.), ensure the CPE references **firmware or hardware correctly**.
    - If multiple entries exist, select the **firmware CPE** when applicable.

    6. **Fallback Handling**
    - If an exact CPE is **unavailable**, return the **closest valid alternative** from NVD.
    - If no CPE exists, return `"null"` for that entry instead of an incorrect or non-existent identifier.

    ### Output Format:
    - Return **only** the JSON object.
    - No explanations, markdown, or additional text.
    """

    return extract_json_from_gpt(query_gpt(client, prompt, "", general_settings, logger))


def products_list_to_cpe_dict(client, general_settings, product_list, logger):
    prompt = f"""
    Convert the following software product list into NVD-compatible CPE 2.3 identifiers that will successfully match entries in the National Vulnerability Database API.

    Task: Generate a JSON object where each key is the software name (exactly as provided) and each value is a CPE that will return results when queried against the NVD database.

    CRITICAL CPE CONSTRUCTION RULES:
    1. For version fields, use "-" (hyphen) instead of "*" when indicating "any version" - this is crucial for NVD API compatibility
    2. For Microsoft Windows products:
       - Windows 11: Use "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:*:*"
       - Windows 10: Use "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*"
       - Windows Server: Use "cpe:2.3:o:microsoft:windows_server_2016:-:*:*:*:*:*:*:*"
    3. For Linux distributions: 
       - Ubuntu: Try both "ubuntu" and "ubuntu_linux" with specific versions like "20.04" or "22.04"
       - Example: "cpe:2.3:o:canonical:ubuntu:22.04:*:*:*:*:*:*:*"
    4. For security products:
       - CrowdStrike: Use "falcon_sensor" instead of just "falcon"
       - Example: "cpe:2.3:a:crowdstrike:falcon_sensor:-:*:*:*:*:*:*:*"
    5. For all CPEs:
       - Check product naming carefully - incorrect product names are the #1 reason for 404 errors
       - When in doubt, use broader product names found in actual NVD entries
       - The hyphen ("-") in the version field is important and different from a wildcard ("*")

    Product list to convert:
    {product_list}
    
    Return only a properly formatted JSON object with CPEs that will successfully return results from the NVD API.
    """
    return extract_json_from_gpt(query_gpt(client, prompt, "", general_settings, logger))

def query_gpt(client, prompt, system_prompt, general_settings, logger):
    """Send prompt to GPT and retrieve the CVEs with logging."""
    
    if not client:
        logger.error("OpenAI client not initialized. Cannot query GPT.")
        return None
        
    try:
        logger.info("Sending query to GPT model...")
            
        # Add explicit instructions for JSON format
        response = ""
        if(system_prompt != ""):
            response = client.chat.completions.create(
                model=general_settings["MODEL"],
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=MAX_TOKENS
            )
        else:
            response = client.chat.completions.create(
                model=general_settings["MODEL"],
                messages=[
                    {"role": "user", "content": prompt}
                ],
                max_tokens=MAX_TOKENS
            )


        # Ensure the response is valid
        if not response or not response.choices:
            logger.error("GPT response is empty or malformed.")
            return None

        # Extract response text safely
        response_text = response.choices[0].message.content.strip() if response.choices and hasattr(response.choices[0], 'message') else ""
        
        if not response_text:
            logger.error("Empty response text from GPT")
            return None

        # Log the full GPT response
        logger.info(f"FULL GPT Response:\n{response_text}")
        return response_text

    except openai.APIConnectionError:
        logger.error("Failed to connect to OpenAI API. Check internet connection.")
        return None

    except openai.OpenAIError as e:
        logger.error(f"OpenAI API error: {str(e)}")
        return None

    except Exception as e:
        logger.error(f"Unexpected error in query_gpt: {str(e)}")
        return None

def create_api_connection(general_settings, logger):
    # Initialize the client with a valid API key
    if general_settings["GPT_API_KEY"] :
        client = openai.OpenAI(api_key=general_settings["GPT_API_KEY"] )
        # Fetch list of available models
        #models = client.models.list()

        # Print all available model names
        #for model in models:
         #   logger.info(model.id)
        return client
    else:
        logger.error("Cannot initialize OpenAI client: API key is missing")


def fix_operator_object_format(json_data):
    """
    Generic function to recursively process JSON and convert any operator-value object
    to string format for compatibility with Elasticsearch.
    
    Converts objects like {'operator': '>', 'value': 1000000} to '> 1000000'
    Works on any nested JSON structure.
    
    Args:
        json_data: Any JSON data structure (dict, list, or primitive)
        
    Returns:
        Processed data with operator objects converted to strings
    """
    import copy
    
    # Deep copy to avoid modifying the original
    processed_data = copy.deepcopy(json_data)
    
    def process_item(item):
        """Recursively process each item in the JSON structure"""
        # Base case: not a dict or list
        if not isinstance(item, (dict, list)):
            return item
            
        # Case: dict - check for operator/value pattern and process each value
        if isinstance(item, dict):
            # Check if this dict is an operator-value object
            if 'operator' in item and 'value' in item:
                operator = item['operator']
                val = item['value']
                
                # Handle different operator types
                if operator == 'in' and isinstance(val, list):
                    # For 'in' operators with lists, format as "in [val1, val2, ...]"
                    return f"in [{', '.join(str(v) for v in val)}]"
                else:
                    # For other operators, format as "operator value"
                    return f"{operator} {val}"
            
            # Not an operator object, process each value recursively
            return {k: process_item(v) for k, v in item.items()}
            
        # Case: list - process each item in the list
        elif isinstance(item, list):
            return [process_item(element) for element in item]
    
    # Start the recursive processing
    return process_item(processed_data)

# Example of where to add this in the upload function:
def preprocess_cve_for_elasticsearch(cve_data):
    """
    Preprocess CVE data for Elasticsearch compatibility.
    Converts operator objects to strings throughout the entire JSON structure.
    """
    # Process the entire vulnerability structure to fix any operator objects
    return fix_operator_object_format(cve_data)

def enrich_cve_data(gpt_client, cve_data, general_settings, logger):
    logger.info("Starting CVE enrichment process")
    logger.info("CVE Data:" + str(cve_data))
    # Get the vulnerabilities from the input dictionary
    vulnerabilities = cve_data.get("vulnerabilities", {})
    
    # Check if we have any vulnerabilities to process
    if not vulnerabilities:
        logger.warning("No vulnerabilities found in input data")
        return cve_data
        
    logger.info(f"Input data contains {len(vulnerabilities)} CVE records")
    
    # Create a copy of the vulnerabilities
    enriched_vulnerabilities = {}
    
    # Copy the vulnerabilities and initialize rule fields
    for cve_id, vuln_data in vulnerabilities.items():
        enriched_vulnerabilities[cve_id] = vuln_data.copy()
        
        # Initialize rule fields with empty objects
        enriched_vulnerabilities[cve_id]["sigma_rules"] = {}
        enriched_vulnerabilities[cve_id]["nuclei_rules"] = {}
        enriched_vulnerabilities[cve_id]["yara_rules"] = {}
        enriched_vulnerabilities[cve_id]["known_exploits"] = {}
    
    logger.debug("Initialized rule fields in vulnerabilities")
    
    # Define separate prompt templates for each rule type
    sigma_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    SIGMA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "sigma_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "sigma_rules": [
        {{
          "title": "Detection of {cve_id}",
          "id": "cve-{cve_id}-detection",
          "status": "experimental",
          "description": "Detects potential exploitation attempts of {cve_id}, a vulnerability in [affected component].",
          "date": "2025-03-19",
          "author": "Security Researcher",
          "logsource": {{
            "category": "process_creation",
            "product": "windows"
          }},
          "detection": {{
            "selection": {{
              "Image": "path/to/vulnerable/binary",
              "CommandLine|contains": "[suspicious pattern]"
            }},
            "condition": "selection"
          }},
          "falsepositives": [
            "Legitimate use cases description"
          ],
          "level": "medium"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    nuclei_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Nuclei templates for scanning systems for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "nuclei_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "nuclei_rules": [
        {{
          "id": "{cve_id}",
          "info": {{
            "name": "[Vulnerability Name]",
            "author": "Security Researcher",
            "severity": "high",
            "description": "Detects [vulnerability description]",
            "tags": [
              "cve",
              "vulnerability-type",
              "affected-system"
            ],
            "reference": [
              "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
            ]
          }},
          "requests": [
            {{
              "method": "GET",
              "path": [
                "/path/to/vulnerable/endpoint"
              ],
              "matchers": [
                {{
                  "type": "word",
                  "words": [
                    "vulnerable response pattern"
                  ],
                  "condition": "contains"
                }}
              ]
            }}
          ]
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    yara_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    YARA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "yara_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "yara_rules": [
        {{
          "rule": "{cve_id}_Detection",
          "meta": {{
            "description": "Detects exploitation attempts of {cve_id}",
            "author": "Security Researcher",
            "date": "2025-03-19",
            "reference": "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
          }},
          "strings": [
            {{
              "id": "$s1",
              "value": "exploit signature pattern 1"
            }},
            {{
              "id": "$s2",
              "value": "exploit signature pattern 2"
            }}
          ],
          "condition": "$s1 and $s2"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    exploits_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Information about known exploit techniques for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "known_exploits"
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "known_exploits": {{
        "techniques": [
          {{
            "name": "Exploitation Method 1",
            "description": "Detailed description of how attackers exploit this vulnerability"
          }},
          {{
            "name": "Exploitation Method 2",
            "description": "Alternative exploitation approach"
          }}
        ],
        "references": [
          "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
        ]
      }}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    
    logger.debug(f"Using separate prompt templates for each rule type")
    
    # Process each vulnerability
    successful_count = 0
    failed_count = 0
    total_count = len(enriched_vulnerabilities)
    logger.info(f"Starting to process {total_count} CVEs...")
    
    # Convert to list for easier iteration with counters
    items = list(enriched_vulnerabilities.items())
    
    for index, (cve_id, vuln_data) in enumerate(items):
        description = vuln_data.get("description", "No description available")
        
        logger.info(f"Processing CVE {index+1}/{total_count}: {cve_id}")
        logger.debug(f"CVE description: {description}")
        
        # Process each rule type separately
        rule_types = [
            {"name": "sigma_rules", "prompt_template": sigma_prompt_template},
            {"name": "nuclei_rules", "prompt_template": nuclei_prompt_template},
            {"name": "yara_rules", "prompt_template": yara_prompt_template},
            {"name": "known_exploits", "prompt_template": exploits_prompt_template}
        ]
        
        for rule_type in rule_types:
            rule_name = rule_type["name"]
            prompt_template = rule_type["prompt_template"]
            
            # Create the specific prompt for this rule type and CVE
            prompt = prompt_template.format(cve_id=cve_id, description=description)
            logger.debug(f"Generated {rule_name} prompt for {cve_id}")
            
            try:
                # Query GPT API
                logger.info(f"Sending {rule_name} request to GPT API for {cve_id}")
                start_time = time.time()
                response = query_gpt(gpt_client, prompt, "", general_settings, logger)
                end_time = time.time()
                
                logger.info(f"Received {rule_name} response from GPT API for {cve_id} in {end_time - start_time:.2f} seconds")
                logger.debug(f"FULL GPT Response for {rule_name}:\n{response}")
                
                # Try standard JSON parsing
                try:
                    # Try direct parsing first
                    try:
                        rules_data = json.loads(repair_json(response))
                    except json.JSONDecodeError:
                        # If that fails, try extracting JSON from the response
                        rules_data = extract_json_from_gpt(repair_json(response))
                        if not rules_data:
                            raise json.JSONDecodeError(f"Could not extract valid JSON for {rule_name}", "", 0)
                    
                    logger.info(f"{rule_name} data: {str(rules_data)}")
                    
                    # Check if the expected key exists in the response
                    if rule_name in rules_data:
                        # Update the vulnerability data with the new rules
                        enriched_vulnerabilities[cve_id][rule_name] = rules_data[rule_name]
                        
                        # Log size of rule data
                        rule_size = len(str(rules_data[rule_name]))
                        logger.info(f"Rule size for {cve_id} {rule_name}: ({rule_size})")
                    else:
                        logger.warning(f"Expected key '{rule_name}' not found in response for {cve_id}")
                        # Keep the initialized empty object
                    
                except Exception as e:
                    error_msg = f"Failed to parse JSON response for {cve_id} {rule_name}: {str(e)}"
                    logger.error(error_msg)
                    logger.error(f"Failed response: {response[:100]}...")
                    # Keep the initialized empty object
            
            except Exception as e:
                error_msg = f"Error processing {cve_id} {rule_name}: {str(e)}"
                logger.error(error_msg)
                # Keep the initialized empty object
            
            # Add delay to avoid rate limiting
            delay_between_requests = general_settings.get("api_delay", 1)
            logger.debug(f"Waiting {delay_between_requests} seconds before next request")
            time.sleep(delay_between_requests)
        
        # Check if all rule types were successfully processed
        if (enriched_vulnerabilities[cve_id]["sigma_rules"] and 
            enriched_vulnerabilities[cve_id]["nuclei_rules"] and 
            enriched_vulnerabilities[cve_id]["yara_rules"] and 
            enriched_vulnerabilities[cve_id]["known_exploits"]):
            successful_count += 1
            logger.info(f"Successfully processed all rule types for {cve_id} ({index+1}/{total_count})")
        else:
            failed_count += 1
            logger.warning(f"Partially processed {cve_id} ({index+1}/{total_count})")
    
    # Log summary statistics
    logger.info("CVE enrichment process completed")
    logger.info(f"Total CVEs processed: {total_count}")
    logger.info(f"Successfully processed all rule types: {successful_count}")
    logger.info(f"Partially or failed to process: {failed_count}")
    
    # Return the enriched vulnerabilities as the result
    result = fix_operator_object_format(enriched_vulnerabilities)
    return result
    #return {"vulnerabilities": result}