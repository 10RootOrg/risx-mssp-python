import openai
import re
import time
import json
from json_repair import repair_json

MAX_TOKENS = 4096  # Ensure model can accept a lot of tokens
def extract_json_from_gpt_old(response):
    json_match = re.search(r'\{.*\}', response, re.DOTALL)
    if json_match:
        json_text = json_match.group(0).strip()
        return json.loads(json_text)
    else:
        raise ValueError("No valid JSON object found in response.")
    
def extract_json_from_gpt(text):
    # Try to find JSON object within the response, even if surrounded by markdown or other text
    pattern = r'(?s)^.*?(\{.*\}).*$'  # Match JSON object inside the text
    match = re.search(pattern, text)
    if match:
        try:
            json_text = match.group(1)
            return json.loads(json_text)
        except json.JSONDecodeError:
            return None
    return None


prompt = f"""
Convert the following software product list into NVD-compatible CPE 2.3 identifiers with specific version information that will match entries in the National Vulnerability Database API.

Task: Generate a JSON object where each key is the software name (exactly as provided) and each value is the most specific CPE that will return results when queried against the NVD database.

CRITICAL CPE CONSTRUCTION RULES:
1. IMPORTANT: Use SPECIFIC VERSION NUMBERS whenever possible instead of generic forms:
   - Example: For "CrushFTP 11" use "cpe:2.3:a:crushftp:crushftp:11.0.0:*:*:*:*:*:*:*"
   - Example: For "Adobe Photoshop 2024" use "cpe:2.3:a:adobe:photoshop_2024:25.0:*:*:*:*:*:*:*"

2. Version numbering guidelines:
   - Use the MOST SPECIFIC VERSION that will match in the NVD database
   - Include all available version components (major.minor.patch)
   - Only use wildcard (*) when necessary for broader matching

3. For Microsoft Windows products:
   - Windows 11: Use "cpe:2.3:o:microsoft:windows_11:22h2:*:*:*:*:*:*:*" (replace with exact build if known)
   - Windows 10: Use "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:*:*" (replace with exact build if known)
   - Windows Server: Include specific version "cpe:2.3:o:microsoft:windows_server:2022:*:*:*:*:*:*:*"

4. For Linux distributions: 
   - Ubuntu: Include version "cpe:2.3:o:canonical:ubuntu:22.04:*:*:*:*:*:*:*"
   - Debian: Include version "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*"

5. For all CPEs:
   - Pay special attention to product naming conventions in the NVD database
   - Check for underscores vs. spaces in product names
   - Ensure vendor names match NVD conventions

6. Research process:
   - First identify the exact CPE format used in the NVD database for each product
   - When in doubt about version format, check existing CVEs for the product

Product list to convert:


Return only a properly formatted JSON object with specific CPEs that will successfully return results from the NVD API.
"""
#line 63 {batch}
def products_list_to_cpe_dict(client, general_settings, product_list, logger, prompt_logger):
    # First, generalize the product names to improve matching
    generalized_products = generalize_product_names(product_list, logger)
    
    # Split the product list into batches of 10
    batch_size = 10
    product_batches = [generalized_products[i:i + batch_size] for i in range(0, len(generalized_products), batch_size)]
    
    combined_results = {}
    prompt_logger.info("Getting CPE json object [To use in NVD]:\n")
    for batch in product_batches:
        prompt = f"""
        Convert the following software product list into NVD-compatible CPE 2.3 identifiers that will successfully match entries in the National Vulnerability Database API. Use general patterns without specific versions.

        Task: Generate a JSON object where each key is the software name (exactly as provided) and each value is a CPE that will return results when queried against the NVD database.

        CRITICAL CPE CONSTRUCTION RULES:
        1. For version fields, use "-" (hyphen) instead of "*" when indicating "any version" - this is crucial for NVD API compatibility
        2. IMPORTANT: For all applications and operating systems, use generic forms without version numbers:
           - Example: "cpe:2.3:a:google:chrome:-:*:*:*:*:*:*:*" instead of specific Chrome versions
           - Example: "cpe:2.3:a:mozilla:firefox:-:*:*:*:*:*:*:*" instead of specific Firefox versions
        3. For Microsoft Windows products:
           - Windows 11: Use "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:*:*"
           - Windows 10: Use "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*"
           - Windows Server: Use "cpe:2.3:o:microsoft:windows_server:-:*:*:*:*:*:*:*"
        4. For Linux distributions: 
           - Ubuntu: Use "cpe:2.3:o:canonical:ubuntu:-:*:*:*:*:*:*:*"
           - Debian: Use "cpe:2.3:o:debian:debian_linux:-:*:*:*:*:*:*:*"
        5. For all CPEs:
           - Always use hyphen ("-") for version field
           - Check product naming carefully - incorrect product names are the #1 reason for 404 errors
           - Focus on the product name that will match in the NVD database

        Product list to convert:
        {batch}
        
        Return only a properly formatted JSON object with CPEs that will successfully return results from the NVD API.
        """
        prompt_logger.info("request prompt:" + prompt)
        # Get response for this batch
        batch_response = query_gpt(client, prompt, "", general_settings, logger)
        prompt_logger.info("response:" + str(batch_response))
        prompt
        try:
            # Option 1: If extract_json_from_gpt returns a dictionary
            batch_json_str = batch_response  # The raw response is a string
            
            # Try to repair the JSON string first
            repaired_json_str = repair_json(batch_json_str)
            
            # Then extract the JSON after repair
            batch_dict = extract_json_from_gpt(repaired_json_str)
            
            # Merge with combined results
            combined_results.update(batch_dict)
            
        except Exception as e:
            logger.error(f"Error processing batch: {e}")
            logger.error(f"Problematic batch: {batch}")
            logger.error(f"Raw response: {batch_response[:500]}...")  # Log first 500 chars of the response
            
            # Fallback repair attempt
            try:
                # Try another approach if the first method fails
                raw_json_str = batch_response
                # Find JSON content between triple backticks if present
                import re
                json_match = re.search(r'```json\s*([\s\S]*?)\s*```', raw_json_str)
                
                if json_match:
                    json_content = json_match.group(1)
                    repaired_json = repair_json(json_content)
                    import json
                    batch_dict = json.loads(repaired_json)
                    combined_results.update(batch_dict)
                    logger.info("Successfully recovered JSON with fallback method")
                else:
                    logger.error("Could not find JSON content in the response")
            except Exception as inner_e:
                logger.error(f"Fallback repair also failed: {inner_e}")
            
    return combined_results

def generalize_product_names(product_list, logger):
    """
    Generalizes product names by removing specific version information
    to improve CPE matching.
    
    Args:
        product_list: List of product strings in format "Name Version"
        logger: Logger object for logging messages
        
    Returns:
        list: List of generalized product names
    """
    logger.info("Generalizing product names for better CPE matching")
    
    generalized_list = []
    
    for product in product_list:
        # Skip empty entries
        if not product or product.isspace():
            continue
            
        # Try to split into name and version
        parts = product.split()
        if len(parts) > 1:
            # Join all but the last part as the name (assuming last part is version)
            original_name = " ".join(parts[:-1])
            generalized_list.append(original_name)
            logger.debug(f"Simplified '{product}' to '{original_name}'")
        else:
            # Only one part, so it's already a name without version
            generalized_list.append(product)
            
    # Remove duplicates while preserving order
    unique_list = []
    seen = set()
    for item in generalized_list:
        if item.lower() not in seen:
            unique_list.append(item)
            seen.add(item.lower())
            
    logger.info(f"Generalized {len(product_list)} products into {len(unique_list)} unique general names")
    return unique_list
def query_gpt(client, prompt, system_prompt, general_settings, logger):
    """Send prompt to GPT and retrieve the CVEs with logging."""
    
    if not client:
        logger.error("OpenAI client not initialized. Cannot query GPT.")
        return None
        
    try:
        logger.info("Sending query to GPT model...")
            
        # Add explicit instructions for JSON format
        response = ""
        if(system_prompt != ""):
            response = client.chat.completions.create(
                model=general_settings["MODEL"],
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=MAX_TOKENS
            )
        else:
            response = client.chat.completions.create(
                model=general_settings["MODEL"],
                messages=[
                    {"role": "user", "content": prompt}
                ],
                max_tokens=MAX_TOKENS
            )


        # Ensure the response is valid
        if not response or not response.choices:
            logger.error("GPT response is empty or malformed.")
            return None

        # Extract response text safely
        response_text = response.choices[0].message.content.strip() if response.choices and hasattr(response.choices[0], 'message') else ""
        
        if not response_text:
            logger.error("Empty response text from GPT")
            return None

        # Log the full GPT response
        logger.info(f"FULL GPT Response:\n{response_text}")
        return response_text

    except openai.APIConnectionError:
        logger.error("Failed to connect to OpenAI API. Check internet connection.")
        return None

    except openai.OpenAIError as e:
        logger.error(f"OpenAI API error: {str(e)}")
        return None

    except Exception as e:
        logger.error(f"Unexpected error in query_gpt: {str(e)}")
        return None

def create_api_connection(general_settings, logger):
    # Initialize the client with a valid API key
    if general_settings["GPT_API_KEY"] :
        client = openai.OpenAI(api_key=general_settings["GPT_API_KEY"] )
        # Fetch list of available models
        #models = client.models.list()

        # Print all available model names
        #for model in models:
         #   logger.info(model.id)
        return client
    else:
        logger.error("Cannot initialize OpenAI client: API key is missing")


def fix_operator_object_format(json_data):
    """
    Generic function to recursively process JSON and convert any operator-value object
    to string format for compatibility with Elasticsearch.
    
    Converts objects like {'operator': '>', 'value': 1000000} to '> 1000000'
    Works on any nested JSON structure.
    
    Args:
        json_data: Any JSON data structure (dict, list, or primitive)
        
    Returns:
        Processed data with operator objects converted to strings
    """
    import copy
    
    # Deep copy to avoid modifying the original
    processed_data = copy.deepcopy(json_data)
    
    def process_item(item):
        """Recursively process each item in the JSON structure"""
        # Base case: not a dict or list
        if not isinstance(item, (dict, list)):
            return item
            
        # Case: dict - check for operator/value pattern and process each value
        if isinstance(item, dict):
            # Check if this dict is an operator-value object
            if 'operator' in item and 'value' in item:
                operator = item['operator']
                val = item['value']
                
                # Handle different operator types
                if operator == 'in' and isinstance(val, list):
                    # For 'in' operators with lists, format as "in [val1, val2, ...]"
                    return f"in [{', '.join(str(v) for v in val)}]"
                else:
                    # For other operators, format as "operator value"
                    return f"{operator} {val}"
            
            # Not an operator object, process each value recursively
            return {k: process_item(v) for k, v in item.items()}
            
        # Case: list - process each item in the list
        elif isinstance(item, list):
            return [process_item(element) for element in item]
    
    # Start the recursive processing
    return process_item(processed_data)

# Example of where to add this in the upload function:
def preprocess_cve_for_elasticsearch(cve_data):
    """
    Preprocess CVE data for Elasticsearch compatibility.
    Converts operator objects to strings throughout the entire JSON structure.
    """
    # Process the entire vulnerability structure to fix any operator objects
    return fix_operator_object_format(cve_data)

def enrich_cve_data(gpt_client, cve_data, general_settings, logger, prompt_logger):
    logger.info("Starting CVE enrichment process")
    logger.info("CVE Data:" + str(cve_data))
    # Get the vulnerabilities from the input dictionary
    vulnerabilities = cve_data.get("vulnerabilities", {})
    
    # Check if we have any vulnerabilities to process
    if not vulnerabilities:
        logger.warning("No vulnerabilities found in input data")
        return cve_data
        
    logger.info(f"Input data contains {len(vulnerabilities)} CVE records")
    
    # Create a copy of the vulnerabilities
    enriched_vulnerabilities = {}
    
    # Copy the vulnerabilities and initialize rule fields
    for cve_id, vuln_data in vulnerabilities.items():
        enriched_vulnerabilities[cve_id] = vuln_data.copy()
        
        # Initialize rule fields with empty objects
        enriched_vulnerabilities[cve_id]["sigma_rules"] = {}
        enriched_vulnerabilities[cve_id]["nuclei_rules"] = {}
        enriched_vulnerabilities[cve_id]["yara_rules"] = {}
        enriched_vulnerabilities[cve_id]["mitigations"] = {}
        enriched_vulnerabilities[cve_id]["known_exploits"] = {}
    
    logger.debug("Initialized rule fields in vulnerabilities")
    
    # Define separate prompt templates for each rule type
    sigma_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    SIGMA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "sigma_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "sigma_rules": [
        {{
          "title": "Detection of {cve_id}",
          "id": "cve-{cve_id}-detection",
          "status": "experimental",
          "description": "Detects potential exploitation attempts of {cve_id}, a vulnerability in [affected component].",
          "date": "2025-03-19",
          "author": "Security Researcher",
          "logsource": {{
            "category": "process_creation",
            "product": "windows"
          }},
          "detection": {{
            "selection": {{
              "Image": "path/to/vulnerable/binary",
              "CommandLine|contains": "[suspicious pattern]"
            }},
            "condition": "selection"
          }},
          "falsepositives": [
            "Legitimate use cases description"
          ],
          "level": "medium"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    nuclei_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Nuclei templates for scanning systems for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "nuclei_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")
    - Matchers MUST use supported fields only. DO NOT include invalid keys like "condition" inside matchers.
    - Use '{{BaseURL}}' in the "path" field to ensure compatibility with Nuclei template engine.

    JSON STRUCTURE EXAMPLE:

    {{
      "nuclei_rules": [
        {{
          "id": "{cve_id}",
          "info": {{
            "name": "[Vulnerability Name]",
            "author": "Security Researcher",
            "severity": "high",
            "description": "Detects [vulnerability description]",
            "tags": [
              "cve",
              "vulnerability-type",
              "affected-system"
            ],
            "reference": [
              "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
            ]
          }},
          "requests": [
            {{
              "method": "GET",
              "path": [
                "{{{{BaseURL}}}}/"
              ],
              "matchers": [
                {{
                  "type": "word",
                  "words": [
                    "vulnerable response pattern"
                  ]
                }}
              ]
            }}
          ]
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """


    yara_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    YARA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "yara_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "yara_rules": [
        {{
          "rule": "{cve_id}_Detection",
          "meta": {{
            "description": "Detects exploitation attempts of {cve_id}",
            "author": "Security Researcher",
            "date": "2025-03-19",
            "reference": "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
          }},
          "strings": [
            {{
              "id": "$s1",
              "value": "exploit signature pattern 1"
            }},
            {{
              "id": "$s2",
              "value": "exploit signature pattern 2"
            }}
          ],
          "condition": "$s1 and $s2"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    exploits_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Information about known exploit techniques for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "known_exploits"
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "known_exploits": {{
        "techniques": [
          {{
            "name": "Exploitation Method 1",
            "description": "Detailed description of how attackers exploit this vulnerability"
          }},
          {{
            "name": "Exploitation Method 2",
            "description": "Alternative exploitation approach"
          }}
        ],
        "references": [
          "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
        ]
      }}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    mitigation_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Detailed mitigation strategies for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "mitigations" 
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "mitigations": {{
        "strategies": [
          {{
            "name": "Patch Installation",
            "description": "Apply the vendor-provided security patch X.Y.Z",
            "difficulty": "medium",
            "effectiveness": "high"
          }},
          {{
            "name": "Configuration Change",
            "description": "Disable vulnerable feature by modifying configuration at path/to/config",
            "difficulty": "low",
            "effectiveness": "medium"
          }},
          {{
            "name": "Workaround",
            "description": "Implement alternative approach that avoids the vulnerability",
            "difficulty": "medium",
            "effectiveness": "medium"
          }}
        ],
        "recommendations": "Primary recommendation for addressing this vulnerability",
        "references": [
          "https://vendor.com/security-advisory/{cve_id}"
        ]
      }}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    logger.debug(f"Using separate prompt templates for each rule type")
    
    # Process each vulnerability
    successful_count = 0
    failed_count = 0
    total_count = len(enriched_vulnerabilities)
    logger.info(f"Starting to process {total_count} CVEs...")
    
    # Convert to list for easier iteration with counters
    items = list(enriched_vulnerabilities.items())
    
    for index, (cve_id, vuln_data) in enumerate(items):
        description = vuln_data.get("description", "No description available")
        
        logger.info(f"Processing CVE {index+1}/{total_count}: {cve_id}")
        logger.debug(f"CVE description: {description}")
        prompt_logger.info("Prompts for " + cve_id)
        # Process each rule type separately
        rule_types = [
            {"name": "sigma_rules", "prompt_template": sigma_prompt_template},
            {"name": "nuclei_rules", "prompt_template": nuclei_prompt_template},
            {"name": "yara_rules", "prompt_template": yara_prompt_template},
            {"name": "mitigations", "prompt_template": mitigation_prompt_template},
            {"name": "known_exploits", "prompt_template": exploits_prompt_template}
        ]
        
        for rule_type in rule_types:
            rule_name = rule_type["name"]
            prompt_template = rule_type["prompt_template"]
            
            # Create the specific prompt for this rule type and CVE
            prompt = prompt_template.format(cve_id=cve_id, description=description)
            logger.debug(f"Generated {rule_name} prompt for {cve_id}")
            
            try:
                # Query GPT API
                logger.info(f"Sending {rule_name} request to GPT API for {cve_id}")
                start_time = time.time()
                prompt_logger.info("Prompt request [" + rule_name + "]:" + prompt)
                response = query_gpt(gpt_client, prompt, "", general_settings, logger)
                prompt_logger.info("Prompt response [" + rule_name + "]:" + response)
                end_time = time.time()
                
                logger.info(f"Received {rule_name} response from GPT API for {cve_id} in {end_time - start_time:.2f} seconds")
                logger.debug(f"FULL GPT Response for {rule_name}:\n{response}")
                
                # Try standard JSON parsing
                try:
                    # Try direct parsing first
                    try:
                        rules_data = json.loads(repair_json(response))
                    except json.JSONDecodeError:
                        # If that fails, try extracting JSON from the response
                        rules_data = extract_json_from_gpt(repair_json(response))
                        if not rules_data:
                            raise json.JSONDecodeError(f"Could not extract valid JSON for {rule_name}", "", 0)
                    
                    logger.info(f"{rule_name} data: {str(rules_data)}")
                    
                    # Check if the expected key exists in the response
                    if rule_name in rules_data:
                        # Update the vulnerability data with the new rules
                        enriched_vulnerabilities[cve_id][rule_name] = rules_data[rule_name]
                        
                        # Log size of rule data
                        rule_size = len(str(rules_data[rule_name]))
                        logger.info(f"Rule size for {cve_id} {rule_name}: ({rule_size})")
                    else:
                        logger.warning(f"Expected key '{rule_name}' not found in response for {cve_id}")
                        # Keep the initialized empty object
                    
                except Exception as e:
                    error_msg = f"Failed to parse JSON response for {cve_id} {rule_name}: {str(e)}"
                    logger.error(error_msg)
                    logger.error(f"Failed response: {response[:100]}...")
                    # Keep the initialized empty object
            
            except Exception as e:
                error_msg = f"Error processing {cve_id} {rule_name}: {str(e)}"
                logger.error(error_msg)
                # Keep the initialized empty object
            
            # Add delay to avoid rate limiting
            delay_between_requests = general_settings.get("api_delay", 1)
            logger.debug(f"Waiting {delay_between_requests} seconds before next request")
            time.sleep(delay_between_requests)
        
        # Check if all rule types were successfully processed
        if (enriched_vulnerabilities[cve_id]["sigma_rules"] and 
            enriched_vulnerabilities[cve_id]["nuclei_rules"] and 
            enriched_vulnerabilities[cve_id]["yara_rules"] and 
            enriched_vulnerabilities[cve_id]["mitigations"] and
            enriched_vulnerabilities[cve_id]["known_exploits"]):
            successful_count += 1
            logger.info(f"Successfully processed all rule types for {cve_id} ({index+1}/{total_count})")
        else:
            failed_count += 1
            logger.warning(f"Partially processed {cve_id} ({index+1}/{total_count})")
    
    # Log summary statistics
    logger.info("CVE enrichment process completed")
    logger.info(f"Total CVEs processed: {total_count}")
    logger.info(f"Successfully processed all rule types: {successful_count}")
    logger.info(f"Partially or failed to process: {failed_count}")
    
    # Return the enriched vulnerabilities as the result
    result = fix_operator_object_format(enriched_vulnerabilities)
    return result
    #return {"vulnerabilities": result}