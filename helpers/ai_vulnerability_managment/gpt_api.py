import openai
import re
import time
import json

MAX_TOKENS = 4096  # Ensure model can accept a lot of tokens
def extract_json_from_gpt_old(response):
    json_match = re.search(r'\{.*\}', response, re.DOTALL)
    if json_match:
        json_text = json_match.group(0).strip()
        return json.loads(json_text)
    else:
        raise ValueError("No valid JSON object found in response.")
    
def extract_json_from_gpt(text):
    # Try to find JSON object within the response, even if surrounded by markdown or other text
    pattern = r'(?s)^.*?(\{.*\}).*$'  # Match JSON object inside the text
    match = re.search(pattern, text)
    if match:
        try:
            json_text = match.group(1)
            return json.loads(json_text)
        except json.JSONDecodeError:
            return None
    return None

def products_list_to_cpe_dict_other(client, general_settings, product_list, logger):
    formatted_products = json.dumps(product_list, indent=2)
    prompt = f"""
    Given the following software names (with optional versions):
    {formatted_products}

    Provide a serialized JSON object mapping each software to its exact standardized CPE (Common Platform Enumeration) identifier.
    - Use the correct numeric version if available, rather than generic labels (e.g., "latest", "H2", "24H2").
    - If the version is unclear or not found, return the closest officially recognized CPE entry from the NVD database.
    - If no version is provided, default to the most stable and widely-used release that has known vulnerabilities.
    - Ensure consistency with official CPE naming conventions from the NVD database.
    - If an exact CPE is unavailable, return the closest valid alternative instead of an incorrect or non-existent entry.

    Return ONLY the JSON object without markdown, explanations, or any additional text.
    """

    return extract_json_from_gpt(query_gpt(client, prompt, "", general_settings, logger))


def products_list_to_cpe_dict(client, general_settings, product_list, logger):
    prompt = f"""
    Convert the following software product list into NVD-compatible CPE 2.3 identifiers that will successfully match entries in the National Vulnerability Database API.

    Task: Generate a JSON object where each key is the software name (exactly as provided) and each value is a CPE that will return results when queried against the NVD database.

    CRITICAL CPE CONSTRUCTION RULES:
    1. For version fields, use "-" (hyphen) instead of "*" when indicating "any version" - this is crucial for NVD API compatibility
    2. For Microsoft Windows products:
       - Windows 11: Use "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:*:*"
       - Windows 10: Use "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*"
       - Windows Server: Use "cpe:2.3:o:microsoft:windows_server_2016:-:*:*:*:*:*:*:*"
    3. For Linux distributions: 
       - Ubuntu: Try both "ubuntu" and "ubuntu_linux" with specific versions like "20.04" or "22.04"
       - Example: "cpe:2.3:o:canonical:ubuntu:22.04:*:*:*:*:*:*:*"
    4. For security products:
       - CrowdStrike: Use "falcon_sensor" instead of just "falcon"
       - Example: "cpe:2.3:a:crowdstrike:falcon_sensor:-:*:*:*:*:*:*:*"
    5. For all CPEs:
       - Check product naming carefully - incorrect product names are the #1 reason for 404 errors
       - When in doubt, use broader product names found in actual NVD entries
       - The hyphen ("-") in the version field is important and different from a wildcard ("*")

    Product list to convert:
    {product_list}
    
    Return only a properly formatted JSON object with CPEs that will successfully return results from the NVD API.
    """
    return extract_json_from_gpt(query_gpt(client, prompt, "", general_settings, logger))

def query_gpt(client, prompt, system_prompt, general_settings, logger):
    """Send prompt to GPT and retrieve the CVEs with logging."""
    
    if not client:
        logger.error("OpenAI client not initialized. Cannot query GPT.")
        return None
        
    try:
        logger.info("Sending query to GPT model...")
            
        # Add explicit instructions for JSON format
        response = ""
        if(system_prompt != ""):
            response = client.chat.completions.create(
                model=general_settings["MODEL"],
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=MAX_TOKENS
            )
        else:
            response = client.chat.completions.create(
                model=general_settings["MODEL"],
                messages=[
                    {"role": "user", "content": prompt}
                ],
                max_tokens=MAX_TOKENS
            )


        # Ensure the response is valid
        if not response or not response.choices:
            logger.error("GPT response is empty or malformed.")
            return None

        # Extract response text safely
        response_text = response.choices[0].message.content.strip() if response.choices and hasattr(response.choices[0], 'message') else ""
        
        if not response_text:
            logger.error("Empty response text from GPT")
            return None

        # Log the full GPT response
        logger.info(f"FULL GPT Response:\n{response_text}")
        return response_text

    except openai.APIConnectionError:
        logger.error("Failed to connect to OpenAI API. Check internet connection.")
        return None

    except openai.OpenAIError as e:
        logger.error(f"OpenAI API error: {str(e)}")
        return None

    except Exception as e:
        logger.error(f"Unexpected error in query_gpt: {str(e)}")
        return None

def create_api_connection(general_settings, logger):
    # Initialize the client with a valid API key
    if general_settings["GPT_API_KEY"] :
        client = openai.OpenAI(api_key=general_settings["GPT_API_KEY"] )
        # Fetch list of available models
        #models = client.models.list()

        # Print all available model names
        #for model in models:
         #   logger.info(model.id)
        return client
    else:
        logger.error("Cannot initialize OpenAI client: API key is missing")


def enrich_cve_data(gpt_client, cve_data, general_settings, logger):
    """
    Enriches CVE data by querying GPT for each CVE to create security rules.
    
    Parameters:
    gpt_client: Client object for GPT API
    cve_data (dict): Dictionary containing CVE information
    general_settings: Configuration settings for the application
    logger: Logger object for logging information
    
    Returns:
    dict: Enriched CVE data with added security rules
    """
    logger.info("Starting CVE enrichment process")
    logger.info("CVE Data:" + str(cve_data))
    # Get the vulnerabilities from the input dictionary
    vulnerabilities = cve_data.get("vulnerabilities", {})
    
    # Check if we have any vulnerabilities to process
    if not vulnerabilities:
        logger.warning("No vulnerabilities found in input data")
        return cve_data
        
    logger.info(f"Input data contains {len(vulnerabilities)} CVE records")
    
    # Create a copy of the vulnerabilities
    enriched_vulnerabilities = {}
    
    # Copy the vulnerabilities and initialize rule fields
    for cve_id, vuln_data in vulnerabilities.items():
        enriched_vulnerabilities[cve_id] = vuln_data.copy()
        
        # Initialize rule fields with empty objects, not strings
        enriched_vulnerabilities[cve_id]["sigma_rules"] = {}
        enriched_vulnerabilities[cve_id]["nuclei_rules"] = {}
        enriched_vulnerabilities[cve_id]["yara_rules"] = {}
        enriched_vulnerabilities[cve_id]["known_exploits"] = {}
    
    logger.debug("Initialized rule fields in vulnerabilities")
    
    prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    1. SIGMA rules for detection of this vulnerability
    2. Nuclei templates for scanning systems for this vulnerability
    3. YARA rules for detection of this vulnerability
    4. Information about known exploit techniques for this vulnerability

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use these exact top-level keys: "sigma_rules", "nuclei_rules", "yara_rules", "known_exploits"
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:
    {{
    "sigma_rules": {{
        "title": "Detection of {cve_id}",
        "id": "unique-id-here",
        "status": "experimental",
        "description": "Description here",
        "date": "2025-03-19",
        "author": "Security Researcher",
        "logsource": {{ "category": "process_creation", "product": "windows" }},
        "detection": {{ "selection": {{}}, "condition": "selection" }},
        "falsepositives": ["possible false positive scenarios"],
        "level": "medium"
    }},
    "nuclei_rules": {{}},
    "yara_rules": {{}},
    "known_exploits": {{}}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    logger.debug(f"Using prompt template: {prompt_template}")
    
    # Process each vulnerability
    successful_count = 0
    failed_count = 0
    total_count = len(enriched_vulnerabilities)
    logger.info(f"Starting to process {total_count} CVEs...")
    
    # Convert to list for easier iteration with counters
    items = list(enriched_vulnerabilities.items())
    
    for index, (cve_id, vuln_data) in enumerate(items):
        description = vuln_data.get("description", "No description available")
        
        logger.info(f"Processing CVE {index+1}/{total_count}: {cve_id}")
        logger.debug(f"CVE description: {description}")
        
        # Create the specific prompt for this CVE
        prompt = prompt_template.format(cve_id=cve_id, description=description)
        logger.debug(f"Generated prompt for {cve_id}")
        
        try:
            # Query GPT API
            logger.info(f"Sending request to GPT API for {cve_id}")
            start_time = time.time()
            response = query_gpt(gpt_client, prompt, "", general_settings, logger)
            end_time = time.time()
            
            logger.info(f"Received response from GPT API for {cve_id} in {end_time - start_time:.2f} seconds")
            logger.info(f"FULL GPT Response:\n{response}")
            
            # Try standard JSON parsing first
            try:
                # Try direct parsing first
                try:
                    rules_data = json.loads(response)
                except json.JSONDecodeError:
                    # If that fails, try extracting JSON from the response
                    rules_data = extract_json_from_gpt(response)
                    if not rules_data:
                        raise json.JSONDecodeError("Could not extract valid JSON", "", 0)
                
                # Ensure all required fields exist as objects
                if "sigma_rules" not in rules_data or not isinstance(rules_data["sigma_rules"], dict):
                    rules_data["sigma_rules"] = {}
                if "nuclei_rules" not in rules_data or not isinstance(rules_data["nuclei_rules"], dict):
                    rules_data["nuclei_rules"] = {}
                if "yara_rules" not in rules_data or not isinstance(rules_data["yara_rules"], dict):
                    rules_data["yara_rules"] = {}
                if "known_exploits" not in rules_data or not isinstance(rules_data["known_exploits"], dict):
                    rules_data["known_exploits"] = {}
                
                # Format date fields correctly in sigma_rules
                if isinstance(rules_data["sigma_rules"], dict) and "date" in rules_data["sigma_rules"]:
                    date_str = rules_data["sigma_rules"]["date"]
                    if isinstance(date_str, str) and "/" in date_str:
                        rules_data["sigma_rules"]["date"] = date_str.replace("/", "-")
                
                # Update the vulnerability data with the new rules
                enriched_vulnerabilities[cve_id]["sigma_rules"] = rules_data["sigma_rules"]
                enriched_vulnerabilities[cve_id]["nuclei_rules"] = rules_data["nuclei_rules"]
                enriched_vulnerabilities[cve_id]["yara_rules"] = rules_data["yara_rules"]
                enriched_vulnerabilities[cve_id]["known_exploits"] = rules_data["known_exploits"]
                
                # Log sizes of each rule type
                sigma_size = len(str(rules_data["sigma_rules"]))
                nuclei_size = len(str(rules_data["nuclei_rules"]))
                yara_size = len(str(rules_data["yara_rules"]))
                exploits_size = len(str(rules_data["known_exploits"]))
                
                logger.info(f"Rule sizes for {cve_id}: SIGMA ({sigma_size}), Nuclei ({nuclei_size}), YARA ({yara_size}), Exploits ({exploits_size})")
                
                successful_count += 1
                logger.info(f"Successfully processed {cve_id} ({index+1}/{total_count})")
                
            except Exception as e:
                failed_count += 1
                error_msg = f"Failed to parse JSON response for {cve_id}: {str(e)}"
                logger.error(error_msg)
                logger.error(f"Failed to parse JSON response for {cve_id}: {response[:100]}...")
                
                # Keep the initialized empty objects
        
        except Exception as e:
            failed_count += 1
            error_msg = f"Error processing {cve_id}: {str(e)}"
            logger.error(error_msg)
            logger.error(f"Error processing {cve_id}: {str(e)}")
            
            # Keep the initialized empty objects
        
        # Add delay to avoid rate limiting
        delay_between_requests = general_settings.get("api_delay", 1)
        logger.debug(f"Waiting {delay_between_requests} seconds before next request")
        time.sleep(delay_between_requests)
    
    # Log summary statistics
    logger.info("CVE enrichment process completed")
    logger.info(f"Total CVEs processed: {total_count}")
    logger.info(f"Successfully processed: {successful_count}")
    logger.info(f"Failed to process: {failed_count}")
    
    # Return the enriched vulnerabilities as the result
    return {"vulnerabilities": enriched_vulnerabilities}