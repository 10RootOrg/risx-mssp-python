import json
import os
import string
import random
from datetime import datetime

# Define the path for the alerts file, making it easy to change later
ALERTS_FILE_PATH = os.path.join("response_folder", "alerts.json")

def id_generator(size=15, chars=string.ascii_letters + string.digits):
    """Generates a random string of a given size."""
    return "".join(random.choice(chars) for _ in range(size))

def load_existing_alerts(logger):
    """
    Safely loads existing alerts from the JSON file.

    This function is designed to be resilient. If the file doesn't exist,
    is empty, or contains invalid data, it returns an empty list.

    Args:
        logger: The logger object for logging messages.

    Returns:
        list: A list of existing alert dictionaries.
    """
    if not os.path.exists(ALERTS_FILE_PATH):
        logger.info(f"Alerts file not found at {ALERTS_FILE_PATH}. Starting with an empty list.")
        return []

    try:
        with open(ALERTS_FILE_PATH, 'r', encoding='utf-8') as f:
            content = f.read()
            if not content.strip():
                logger.info("Alerts file is empty. Starting with an empty list.")
                return []
            
            alerts = json.loads(content)
            
            # CRITICAL FIX: Ensure the loaded data is a list.
            if isinstance(alerts, list):
                logger.info(f"Successfully loaded {len(alerts)} existing alerts.")
                return alerts
            else:
                logger.warning("Alerts file does not contain a list. Starting fresh.")
                return []
                
    except (json.JSONDecodeError, IOError) as e:
        logger.error(f"Error reading or parsing alerts file: {e}. Starting with an empty list.")
        return []

def save_alerts(alerts, logger):
    """
    Saves the list of alerts back to the JSON file.

    Args:
        alerts (list): The list of alerts to save.
        logger: The logger object for logging messages.
    """
    try:
        # Ensure the directory exists before writing
        os.makedirs(os.path.dirname(ALERTS_FILE_PATH), exist_ok=True)
        with open(ALERTS_FILE_PATH, 'w', encoding='utf-8') as f:
            json.dump(alerts, f, indent=4, ensure_ascii=False)
        logger.info(f"Successfully saved {len(alerts)} alerts to {ALERTS_FILE_PATH}.")
    except IOError as e:
        logger.error(f"Failed to write alerts to file: {e}")

def add_new_alerts(final_cve_obj, logger):
    """
    Adds new CVEs as alerts using the specified format, avoiding duplicates.

    Args:
        final_cve_obj (dict): The dictionary of CVEs from the main script.
        logger: The logger object for logging messages.
    """
    # Load existing alerts safely
    existing_alerts = load_existing_alerts(logger)
    
    # Create a set of existing CVE IDs for fast, efficient duplicate checking.
    # This uses the "CVE" key from the alert structure you provided.
    existing_cve_ids = {alert.get("CVE") for alert in existing_alerts}
    
    new_alerts_added = 0
    
    # Determine the correct dictionary of vulnerabilities to iterate over.
    # This handles if the data is nested under a "vulnerabilities" key or not.
    vulnerabilities = final_cve_obj.get("vulnerabilities", final_cve_obj)
    
    if isinstance(vulnerabilities, dict):
        for cve_name, cve_data in vulnerabilities.items():
            # Check if this CVE has already been alerted on
            if cve_name not in existing_cve_ids:
                
                # --- This now uses the alert structure you specified ---
                new_alert = {
                    "Artifact": "Custom.10root.CVE.Management",
                    "CVE": cve_name,
                    "timestamp": datetime.utcnow().isoformat() + "Z", # Using standard ISO 8601 format
                    "ProductName": cve_data.get("product_name", "Unknown"),
                    "CVE Description": cve_data.get("description", ""),
                    "CVSS": cve_data.get("cvss_v3", 0.0),
                    "Published": cve_data.get("published", ""),
                    "Last Modified": cve_data.get("last_modified", ""),
                    "AlertID": id_generator(),
                    "UserInput": {
                        "UserId": "",
                        "Status": "New",
                        "ChangedAt": ""
                    }
                }
                
                existing_alerts.append(new_alert)
                existing_cve_ids.add(cve_name)
                new_alerts_added += 1

    if new_alerts_added > 0:
        logger.info(f"Adding {new_alerts_added} new alerts.")
        save_alerts(existing_alerts, logger)
    else:
        logger.info("No new vulnerabilities to add as alerts.")

