import openai
import re
import time
import json
from json_repair import repair_json
import datetime

from helpers.ai_vulnerability_managment.apis.gemini import GeminiAPI
from helpers.ai_vulnerability_managment.apis.gpt import ChatGPTAPI
from helpers.ai_vulnerability_managment.apis.claude import ClaudeAPI

def get_llm_api(general_settings, logger):
    """
    Factory function to get the appropriate LLM API client based on vendor_name.
    """
    logger.info("general settings:" + str(general_settings))
    vendor = general_settings['VENDOR_NAME'].lower()
    logger.info("Vendor:" + vendor)
    if vendor == "chatgpt":
        logger.info("Using ChatGPT API")
        return ChatGPTAPI(general_settings, logger)
    elif vendor == "claude":
        logger.info("Using Claude API")
        return ClaudeAPI(general_settings, logger)
    elif vendor == "gemini":
        logger.info("Using Gemini API")
        return GeminiAPI(general_settings, logger)
    else:
        error_msg = f"Unsupported vendor: {vendor}"
        logger.error(error_msg)
        raise ValueError(error_msg)
    
MAX_TOKENS = 15000  # Ensure model can accept a lot of tokens

def extract_json_from_gpt(text):
    # Try to find JSON object within the response, even if surrounded by markdown or other text
    pattern = r'(?s)^.*?(\{.*\}).*$'  # Match JSON object inside the text
    match = re.search(pattern, text)
    if match:
        try:
            json_text = match.group(1)
            return json.loads(json_text)
        except json.JSONDecodeError:
            return None
    return None


import re
import json

# ==============================================================================
# Main Function to Convert Products to CPEs (with updated dynamic prompt)
# ==============================================================================

def products_list_to_cpe_dict(llm_api_client, general_settings, product_list, logger, prompt_logger):
    """
    Converts a list of product names into a dictionary of NVD-compatible CPEs
    by sending the raw product list directly to the LLM with a robust prompt.
    """
    # Remove duplicates from the initial list while preserving order
    unique_products = list(dict.fromkeys(product_list))
    
    batch_size = 10
    product_batches = [unique_products[i:i + batch_size] for i in range(0, len(unique_products), batch_size)]
    
    combined_results = {}
    
    prompt_logger.info("Getting CPE json object [To use in NVD]:\n")
    prompt_logger.info("---------------------------------------------------")

    # The system prompt instructs the AI on its role and output format.
    system_prompt = """You are an expert vulnerability analyst specializing in NVD and CPE formats. Your task is to convert a list of product names into generic, NVD-compatible CPE 2.3 identifiers. Your output must be a single, valid JSON object without any extra explanations or markdown."""
    
    for batch in product_batches:
        # --- THIS PROMPT IS NOW FULLY DYNAMIC ---
        # It instructs the AI on how to generalize names itself, removing the need for a separate function.
        
        old_rompt = f"""
        Convert the following product list into NVD-compatible CPE 2.3 identifiers.

        Task:
        For each product in the list, identify the core product name, ignoring specific version numbers unless the version is part of the official product name (like 'Windows 10'). Then, generate a JSON object where the key is the original product name and the value is the corresponding generic CPE string.

        CRITICAL CPE CONSTRUCTION RULES:
        1.  **Always use a wildcard for the version**: The version field in the CPE string must ALWAYS be a hyphen "-".
        2.  **Handle OSes Correctly**:
            -   Input "Windows 10" -> Identify product "windows_10" -> CPE: "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*"
            -   Input "Windows 11 23H2" -> Identify product "windows_11" -> CPE: "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:*:*"
        3.  **Handle Applications/Drivers Correctly**:
            -   Input "NVIDIA GPU Driver 555.99" -> Identify product "gpu_driver" -> CPE: "cpe:2.3:a:nvidia:gpu_driver:-:*:*:*:*:*:*:*"
            -   Input "Adobe Photoshop 2024" -> Identify product "photoshop" -> CPE: "cpe:2.3:a:adobe:photoshop:-:*:*:*:*:*:*:*"
        4.  **Vendor and Product Names**: Accurately identify the official vendor and product names as used by NVD (e.g., 'microsoft', not 'MS'; 'gpu_driver', not 'gpu driver').
        5.  **Format**: Return ONLY a single, valid JSON object.

        Product list to convert:
        {batch}
        """
        prompt = f"""
Convert the following product list into NVD-compatible CPE 2.3 identifiers.

Task:
For each product in the list, generate a JSON object where the key is the original product name and the value is the corresponding CPE string. Use specific versions when clearly provided, otherwise use general CPE strings.

CRITICAL CPE CONSTRUCTION RULES:
1.  **Version Handling Strategy**:
    - If input contains a CLEAR, SPECIFIC version (e.g., "Apache Log4j 2.14.1", "Windows 10", "Chrome 91.0.4472.124"), include that exact version in the CPE
    - If input is vague about version (e.g., "latest", "2024", "current") or no version provided, use a hyphen "-" for the version field
    - If input mentions a major version only (e.g., "Java 8", "Python 3"), use that major version

2.  **CPE Format Examples**:
    - Specific version: "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*"
    - General/no version: "cpe:2.3:a:apache:log4j:-:*:*:*:*:*:*:*"
    - Major version: "cpe:2.3:a:oracle:jdk:8:*:*:*:*:*:*:*"

3.  **Handle Different Product Types**:
    - **Operating Systems**: Use "o:" prefix (e.g., "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*")
    - **Applications**: Use "a:" prefix (e.g., "cpe:2.3:a:adobe:photoshop:-:*:*:*:*:*:*:*")
    - **Hardware**: Use "h:" prefix when applicable

4.  **Product Name Mapping**:
    - Apache Log4j → "log4j" (use standard product name unless specifically mentioned as "core")
    - Windows versions: "Windows 10" → "windows_10", "Windows 11" → "windows_11"
    - Use official vendor and product names as recognized by NVD (lowercase, underscores for spaces)

5.  **Format**: Return ONLY a single, valid JSON object.

Product list to convert:
{batch}
"""
        prompt_logger.info("Request prompt:\n" + prompt)
        prompt_logger.info("***************************************************")
        
        # Get response for this batch
        batch_response = llm_api_client.send_request(system_prompt, prompt, temperature=0.7, max_tokens=15000)
        
        prompt_logger.info("Response:\n" + str(batch_response))
        prompt_logger.info("---------------------------------------------------")

        try:
            # Attempt to extract and parse the JSON from the response
            batch_dict = extract_json_from_gpt(batch_response)
            if batch_dict:
                combined_results.update(batch_dict)
        except Exception as e:
            logger.error(f"Failed to process and parse response for batch: {batch}. Error: {e}")
            logger.error(f"Raw response was: {batch_response[:500]}")
            # Optional: Add fallback/retry logic here if needed
            
    return combined_results


# ==============================================================================
# Helper function to extract JSON (no changes needed here)
# ==============================================================================

def extract_json_from_gpt(response_text):
    """
    A robust function to find and parse a JSON object from a string,
    even if it's embedded in text or markdown.
    """
    # Find JSON content between triple backticks if present
    json_match = re.search(r'```json\s*([\s\S]*?)\s*```', response_text)
    if json_match:
        json_content = json_match.group(1)
    else:
        # If no markdown, assume the whole string might be JSON or contain it
        # Find the first '{' and last '}'
        start = response_text.find('{')
        end = response_text.rfind('}')
        if start != -1 and end != -1 and end > start:
            json_content = response_text[start:end+1]
        else:
            raise ValueError("No valid JSON object found in the response.")

    try:
        # Here you might call a `repair_json` function if you have one
        return json.loads(json_content)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse extracted JSON: {e}") from e

def fix_operator_object_format(json_data):
    """
    Generic function to recursively process JSON and convert any operator-value object
    to string format for compatibility with Elasticsearch.
    
    Converts objects like {'operator': '>', 'value': 1000000} to '> 1000000'
    Works on any nested JSON structure.
    
    Args:
        json_data: Any JSON data structure (dict, list, or primitive)
        
    Returns:
        Processed data with operator objects converted to strings
    """
    import copy
    
    # Deep copy to avoid modifying the original
    processed_data = copy.deepcopy(json_data)
    
    def process_item(item):
        """Recursively process each item in the JSON structure"""
        # Base case: not a dict or list
        if not isinstance(item, (dict, list)):
            return item
            
        # Case: dict - check for operator/value pattern and process each value
        if isinstance(item, dict):
            # Check if this dict is an operator-value object
            if 'operator' in item and 'value' in item:
                operator = item['operator']
                val = item['value']
                
                # Handle different operator types
                if operator == 'in' and isinstance(val, list):
                    # For 'in' operators with lists, format as "in [val1, val2, ...]"
                    return f"in [{', '.join(str(v) for v in val)}]"
                else:
                    # For other operators, format as "operator value"
                    return f"{operator} {val}"
            
            # Not an operator object, process each value recursively
            return {k: process_item(v) for k, v in item.items()}
            
        # Case: list - process each item in the list
        elif isinstance(item, list):
            return [process_item(element) for element in item]
    
    # Start the recursive processing
    return process_item(processed_data)
    
# Example of where to add this in the upload function:
def preprocess_cve_for_elasticsearch(cve_data):
    """
    Preprocess CVE data for Elasticsearch compatibility.
    Converts operator objects to strings throughout the entire JSON structure.
    """
    # Process the entire vulnerability structure to fix any operator objects
    return fix_operator_object_format(cve_data)

def enrich_cve_data(llm_api_client, cve_data, general_settings, logger, prompt_logger):
    logger.info("Starting CVE enrichment process")
    logger.info("CVE Data:" + str(cve_data))
    # Get the vulnerabilities from the input dictionary
    vulnerabilities = cve_data.get("vulnerabilities", {})
    
    # Check if we have any vulnerabilities to process
    if not vulnerabilities:
        logger.warning("No vulnerabilities found in input data")
        return cve_data
        
    logger.info(f"Input data contains {len(vulnerabilities)} CVE records")
    
    # Create a copy of the vulnerabilities
    enriched_vulnerabilities = {}
    # epoch_time = time.time()
    now = time.gmtime()
    iso_format = time.strftime("%Y-%m-%dT%H:%M:%S", now) + f".{int(datetime.datetime.utcnow().microsecond / 1000):03d}Z"

    # Copy the vulnerabilities and initialize rule fields
    for cve_id, vuln_data in vulnerabilities.items():
        enriched_vulnerabilities[cve_id] = vuln_data.copy()
        
        # Initialize rule fields with empty objects
        enriched_vulnerabilities[cve_id]["sigma_rules"] = {}
        enriched_vulnerabilities[cve_id]["nuclei_rules"] = {}
        enriched_vulnerabilities[cve_id]["yara_rules"] = {}
        enriched_vulnerabilities[cve_id]["mitigations"] = {}
        enriched_vulnerabilities[cve_id]["known_exploits"] = {}
        enriched_vulnerabilities[cve_id]["run_date"] = iso_format
    
    logger.debug("Initialized rule fields in vulnerabilities")
    
    sigma_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    SIGMA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "sigma_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "sigma_rules": [
        {{
          "title": "Detection of {cve_id}",
          "id": "cve-{cve_id}-detection",
          "status": "experimental",
          "description": "Detects potential exploitation attempts of {cve_id}, a vulnerability in [affected component].",
          "date": "2025-03-19",
          "author": "Security Researcher",
          "logsource": {{
            "category": "process_creation",
            "product": "windows"
          }},
          "detection": {{
            "selection": {{
              "Image": "path/to/vulnerable/binary",
              "CommandLine|contains": "[suspicious pattern]"
            }},
            "condition": "selection"
          }},
          "falsepositives": [
            "Legitimate use cases description"
          ],
          "level": "medium"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    nuclei_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Nuclei templates for scanning systems for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "nuclei_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")
    - Matchers MUST use supported fields only. DO NOT include invalid keys like "condition" inside matchers.
    - Use '{{BaseURL}}' in the "path" field to ensure compatibility with Nuclei template engine.

    JSON STRUCTURE EXAMPLE:

    {{
      "nuclei_rules": [
        {{
          "id": "{cve_id}",
          "info": {{
            "name": "[Vulnerability Name]",
            "author": "Security Researcher",
            "severity": "high",
            "description": "Detects [vulnerability description]",
            "tags": [
              "cve",
              "vulnerability-type",
              "affected-system"
            ],
            "reference": [
              "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
            ]
          }},
          "requests": [
            {{
              "method": "GET",
              "path": [
                "{{{{BaseURL}}}}/"
              ],
              "matchers": [
                {{
                  "type": "word",
                  "words": [
                    "vulnerable response pattern"
                  ]
                }}
              ]
            }}
          ]
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """


    yara_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    YARA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "yara_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "yara_rules": [
        {{
          "rule": "{cve_id}_Detection",
          "meta": {{
            "description": "Detects exploitation attempts of {cve_id}",
            "author": "Security Researcher",
            "date": "2025-03-19",
            "reference": "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
          }},
          "strings": [
            {{
              "id": "$s1",
              "value": "exploit signature pattern 1"
            }},
            {{
              "id": "$s2",
              "value": "exploit signature pattern 2"
            }}
          ],
          "condition": "$s1 and $s2"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    exploits_prompt_template = """
For the vulnerability {cve_id} ({description}), please SEARCH FOR and REPORT on EXISTING public exploits:
Information about known exploit techniques, exploit availability, and attack groups associated with this vulnerability.

CRITICAL JSON FORMATTING INSTRUCTIONS:
- Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
- The response must start with {{ and end with }} without any other characters before or after.
- Do NOT wrap the response in markdown code blocks (```json).
- Use the top-level key: "known_exploits"
- For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

JSON STRUCTURE EXAMPLE:

{{
  "known_exploits": {{
    "public_exploits": [
      {{
        "name": "Exploit Name/ID",
        "url": "https://link-to-public-exploit.com/exploit",
        "description": "Brief description of the exploit"
      }}
    ],
    "exploit_availability": "Available/Limited/Not Available",
    "threat_actors": [
      {{
        "name": "Threat Actor/Group Name",
        "activity": "Description of their activity related to this CVE"
      }}
    ],
    "references": [
      "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
      "https://other-relevant-resource.com/cve-details"
    ]
  }}
}}

DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
"""
    mitigation_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Detailed mitigation strategies for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "mitigations" 
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "mitigations": {{
        "strategies": [
          {{
            "name": "Patch Installation",
            "description": "Apply the vendor-provided security patch X.Y.Z",
            "difficulty": "medium",
            "effectiveness": "high"
          }},
          {{
            "name": "Configuration Change",
            "description": "Disable vulnerable feature by modifying configuration at path/to/config",
            "difficulty": "low",
            "effectiveness": "medium"
          }},
          {{
            "name": "Workaround",
            "description": "Implement alternative approach that avoids the vulnerability",
            "difficulty": "medium",
            "effectiveness": "medium"
          }}
        ],
        "recommendations": "Primary recommendation for addressing this vulnerability",
        "references": [
          "https://vendor.com/security-advisory/{cve_id}"
        ]
      }}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    logger.debug(f"Using separate prompt templates for each rule type")
    
    # Process each vulnerability
    successful_count = 0
    failed_count = 0
    total_count = len(enriched_vulnerabilities)
    logger.info(f"Starting to process {total_count} CVEs...")
    
    # Convert to list for easier iteration with counters
    items = list(enriched_vulnerabilities.items())
    
    for index, (cve_id, vuln_data) in enumerate(items):
        description = vuln_data.get("description", "No description available")
        
        logger.info(f"Processing CVE {index+1}/{total_count}: {cve_id}")
        logger.debug(f"CVE description: {description}")
        prompt_logger.info("Prompts for " + cve_id)
        prompt_logger.info("---------------------------------------------------")
        # Process each rule type separately
        rule_types = [
            {"name": "sigma_rules", "prompt_template": sigma_prompt_template},
            {"name": "nuclei_rules", "prompt_template": nuclei_prompt_template},
            {"name": "yara_rules", "prompt_template": yara_prompt_template},
            {"name": "mitigations", "prompt_template": mitigation_prompt_template},
            {"name": "known_exploits", "prompt_template": exploits_prompt_template}
        ]
        
        for rule_type in rule_types:
            rule_name = rule_type["name"]
            prompt_template = rule_type["prompt_template"]
            
            # Create the specific prompt for this rule type and CVE
            prompt = prompt_template.format(cve_id=cve_id, description=description)
            logger.debug(f"Generated {rule_name} prompt for {cve_id}")
            
            try:
                # Query GPT API
                logger.info(f"Sending {rule_name} request to GPT API for {cve_id}")
                start_time = time.time()
                prompt_logger.info("Prompt request [" + rule_name + "]:\n" + prompt)
                prompt_logger.info("***************************************************")
                response = llm_api_client.send_request("", prompt, temperature=0.7, max_tokens=15000)
                prompt_logger.info("Prompt response [" + rule_name + "]:\n" + response)
                prompt_logger.info("---------------------------------------------------")
                end_time = time.time()
                
                logger.info(f"Received {rule_name} response from GPT API for {cve_id} in {end_time - start_time:.2f} seconds")
                logger.debug(f"FULL GPT Response for {rule_name}:\n{response}")
                
                # Try standard JSON parsing
                try:
                    # Try direct parsing first
                    try:
                        rules_data = json.loads(repair_json(response))
                    except json.JSONDecodeError:
                        # If that fails, try extracting JSON from the response
                        rules_data = extract_json_from_gpt(repair_json(response))
                        if not rules_data:
                            raise json.JSONDecodeError(f"Could not extract valid JSON for {rule_name}", "", 0)
                    
                    logger.info(f"{rule_name} data: {str(rules_data)}")
                    
                    # Check if the expected key exists in the response
                    if rule_name in rules_data:
                        # Update the vulnerability data with the new rules
                        enriched_vulnerabilities[cve_id][rule_name] = rules_data[rule_name]
                        
                        # Log size of rule data
                        rule_size = len(str(rules_data[rule_name]))
                        logger.info(f"Rule size for {cve_id} {rule_name}: ({rule_size})")
                    else:
                        logger.warning(f"Expected key '{rule_name}' not found in response for {cve_id}")
                        # Keep the initialized empty object
                    
                except Exception as e:
                    error_msg = f"Failed to parse JSON response for {cve_id} {rule_name}: {str(e)}"
                    logger.error(error_msg)
                    logger.error(f"Failed response: {response[:100]}...")
                    # Keep the initialized empty object
            
            except Exception as e:
                error_msg = f"Error processing {cve_id} {rule_name}: {str(e)}"
                logger.error(error_msg)
                # Keep the initialized empty object
            
            # Add delay to avoid rate limiting
            delay_between_requests = general_settings.get("api_delay", 1)
            logger.debug(f"Waiting {delay_between_requests} seconds before next request")
            time.sleep(delay_between_requests)
        
        # Check if all rule types were successfully processed
        if (enriched_vulnerabilities[cve_id]["sigma_rules"] and 
            enriched_vulnerabilities[cve_id]["nuclei_rules"] and 
            enriched_vulnerabilities[cve_id]["yara_rules"] and 
            enriched_vulnerabilities[cve_id]["mitigations"] and
            enriched_vulnerabilities[cve_id]["known_exploits"]):
            successful_count += 1
            logger.info(f"Successfully processed all rule types for {cve_id} ({index+1}/{total_count})")
        else:
            failed_count += 1
            logger.warning(f"Partially processed {cve_id} ({index+1}/{total_count})")
    
    # Log summary statistics
    logger.info("CVE enrichment process completed")
    logger.info(f"Total CVEs processed: {total_count}")
    logger.info(f"Successfully processed all rule types: {successful_count}")
    logger.info(f"Partially or failed to process: {failed_count}")
    
    # Return the enriched vulnerabilities as the result
    result = fix_operator_object_format(enriched_vulnerabilities)
    return result
    #return {"vulnerabilities": result}