
import datetime
import requests
import json
import time
import re

def get_cves_from_nvd(max_vulnerabilities=100, start_date=None, cpe_dict=None, 
                      min_cvss_score=None, api_key=None, logger=None):
    """
    Fetch CVEs from NVD API and return as a JSON object without pandas dependencies.
    
    Parameters:
        max_vulnerabilities (int): Maximum number of vulnerabilities to fetch
        start_date (str): Starting date for vulnerability publication (YYYY-MM-DD)
        cpe_dict (dict): Dictionary mapping product names to CPE strings
        min_cvss_score (float): Minimum CVSS score to include
        api_key (str): NVD API key
        logger: Logger object
        
    Returns:
        dict: JSON object containing vulnerability data
    """
    # Initialize result dictionary
    result = {}
    
    # Set default dates if not provided
    end_date = datetime.datetime.now().strftime("%Y-%m-%d")
    if start_date is None:
        # Default to 30 days ago if not specified
        start_date = (datetime.datetime.now() - datetime.timedelta(days=30)).strftime("%Y-%m-%d")
    
    if logger:
        logger.info(f"Date range: {start_date} to {end_date}")
    else:
        # Create a simple print-based logger if none provided
        class SimpleLogger:
            def info(self, msg): print(f"INFO: {msg}")
            def warning(self, msg): print(f"WARNING: {msg}")
            def error(self, msg): print(f"ERROR: {msg}")
        logger = SimpleLogger()
    
    # Format dates properly for the API
    start_timestamp = f"{start_date}T00:00:00.000"
    end_timestamp = f"{end_date}T23:59:59.999"
    logger.info("NVD Start date:" + str(start_timestamp))
    logger.info("NVD End date:" + str(end_timestamp))
    # Initialize the vulnerabilities object with empty values
    vulnerabilities = {}
    # Default to empty dict if None
    if cpe_dict is None:
        cpe_dict = {'No specific product': ''}  # Empty string means no CPE filter
    elif isinstance(cpe_dict, str):
        # Convert single string to dict with generic product name
        cpe_dict = {'Generic Product': cpe_dict}
    
    # Ensure max_vulnerabilities has a reasonable value
    if not isinstance(max_vulnerabilities, int) or max_vulnerabilities <= 0:
        logger.warning(f"Invalid max_vulnerabilities: {max_vulnerabilities}, defaulting to 100")
        max_vulnerabilities = 100
    
    logger.info(f"Will fetch up to {max_vulnerabilities} vulnerabilities")
    logger.info(f"Product and CPE filters: {cpe_dict}")
    
    # Track total unique vulnerabilities across all products
    all_vulnerabilities = {}
    
    # Process each product and its CPE
    for product_name, cpe_name in cpe_dict.items():
        try:
            logger.info(f"Processing Product: {product_name}, CPE: {cpe_name if cpe_name else 'No specific CPE'}")
            
            # Make API request
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                "resultsPerPage": min(100, max_vulnerabilities),
                "pubStartDate": start_timestamp,
                "pubEndDate": end_timestamp,
            }
            headers = {}
            
            if cpe_name:
                params["cpeName"] = cpe_name
                
            if api_key:
                headers["apiKey"] = api_key
                
            try:
                logger.info(f"Requesting CVEs from {start_timestamp} to {end_timestamp}" + 
                           (f" for CPE {cpe_name}" if cpe_name else ""))
                
                response = requests.get(url, headers=headers, params=params, timeout=30)
                logger.info(f"Request URL: {response.url}")
                logger.info(f"Status Code: {response.status_code}")
                
                if response.status_code != 200:
                    logger.error(f"API returned error status: {response.status_code}")
                    continue
                    
                data = response.json()
                vulnerabilities = data.get("vulnerabilities", [])
                
                if not vulnerabilities:
                    logger.warning(f"No vulnerabilities found for Product: {product_name}, CPE: {cpe_name if cpe_name else 'No specific CPE'}")
                    continue
                
                # Process each vulnerability
                for vuln in vulnerabilities:
                    cve_data = vuln.get("cve", {})
                    cve_id = cve_data.get("id", "Unknown")
                    
                    # Extract description
                    descriptions = cve_data.get("descriptions", [])
                    description = "No description available"
                    for desc in descriptions:
                        if desc.get("lang") == "en":
                            description = desc.get("value", "No description available")
                            break
                    
                    # Extract CVSS scores
                    metrics = cve_data.get("metrics", {})
                    cvss_v31 = metrics.get("cvssMetricV31", [])
                    cvss_v30 = metrics.get("cvssMetricV30", [])
                    
                    # Get CVSS v3 score (prefer v3.1, fall back to v3.0)
                    base_score_v3 = None
                    if cvss_v31:
                        base_score_v3 = cvss_v31[0].get("cvssData", {}).get("baseScore")
                    elif cvss_v30:
                        base_score_v3 = cvss_v30[0].get("cvssData", {}).get("baseScore")
                    
                    # Convert CVSS score to float for comparison
                    cvss_float = 0.0
                    if base_score_v3 is not None:
                        try:
                            cvss_float = float(base_score_v3)
                        except (ValueError, TypeError):
                            cvss_float = 0.0
                    
                    # Skip if below minimum CVSS score
                    if min_cvss_score is not None:
                        try:
                            min_score = float(min_cvss_score)
                            if cvss_float < min_score:
                                continue
                        except (ValueError, TypeError):
                            # If conversion fails, don't filter
                            pass
                    
                    # Extract dates
                    published = cve_data.get("published")
                    last_modified = cve_data.get("lastModified")
                    
                    # Extract references
                    references = cve_data.get("references", [])
                    reference_urls = [ref.get("url", "No URL") for ref in references]
                    
                    # Create a dictionary for this vulnerability
                    vuln_dict = {
                        "cve_id": cve_id,
                        "description": description,
                        "cvss_v3": base_score_v3,
                        "published": published,
                        "last_modified": last_modified,
                        "references": reference_urls,
                        "cpe": cpe_name if cpe_name else "none",
                        "product_name": product_name
                    }
                    
                    # Add to our results if it's new or has a higher CVSS score
                    if cve_id in all_vulnerabilities:
                        existing_cvss = 0.0
                        existing_score = all_vulnerabilities[cve_id].get("cvss_v3")
                        if existing_score is not None:
                            try:
                                existing_cvss = float(existing_score)
                            except (ValueError, TypeError):
                                existing_cvss = 0.0
                                
                        if cvss_float > existing_cvss:
                            all_vulnerabilities[cve_id] = vuln_dict
                    else:
                        all_vulnerabilities[cve_id] = vuln_dict
                
                logger.info(f"Found {len(vulnerabilities)} vulnerabilities for Product: {product_name}, CPE: {cpe_name if cpe_name else 'No specific CPE'}")
                
            except requests.exceptions.RequestException as e:
                logger.error(f"Request failed: {str(e)}")
                continue
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse API response: {str(e)}")
                continue
            except Exception as e:
                logger.error(f"Error processing API response: {str(e)}")
                continue
            
            # Respect API rate limits
            time.sleep(1.5)
            
        except Exception as e:
            logger.error(f"Error processing Product: {product_name}, CPE: {cpe_name}: {str(e)}")
    
    # Sort vulnerabilities by CVSS score
    sorted_vulns = {}
    try:
        # Create list of (cve_id, cvss) tuples for sorting
        vuln_scores = []
        for cve_id, vuln in all_vulnerabilities.items():
            cvss = 0.0
            cvss_str = vuln.get("cvss_v3")
            if cvss_str is not None:
                try:
                    cvss = float(cvss_str)
                except (ValueError, TypeError):
                    cvss = 0.0
            vuln_scores.append((cve_id, cvss))
        
        # Sort by CVSS (descending)
        vuln_scores.sort(key=lambda x: x[1], reverse=True)
        
        # Create sorted dictionary
        for cve_id, _ in vuln_scores:
            sorted_vulns[cve_id] = all_vulnerabilities[cve_id]
            
    except Exception as e:
        logger.error(f"Error sorting vulnerabilities: {str(e)}")
        sorted_vulns = all_vulnerabilities  # Use unsorted if sorting fails
    
    # Add results to final output
    result["vulnerabilities"] = sorted_vulns
    
    if min_cvss_score is not None:
        logger.info(f"Filtered to vulnerabilities with CVSS score >= {min_cvss_score}")
    
    return result